// ****** Source: README.md******
# Proyecto base para APIs del sistema Logistic Engine

logistic-engine-base-project

## Contexto

Se crea proyecto semilla (template) basado en proyecto base para servicios rest propuesto por arquitectura. https://bitbucket.org/ripleyx/rest-template-nj/src/master/
realizando ciertas modificaciones de estructura de carpetas para asi favorecer los principios que permiten generar un codigo limpio, inspirandose en parte de los patrones propuestos por Clean Architecture.

Construido con

- NodeJs
- Typescript
- Express

## Comandos de aplicacion

```shell

# instalacion de dependencias
npm install

# preparacion de git hook
npm run prepare

# ejecucion de solucion en ambiente desarrollo
npm run dev

npm run dev:debug

# ejecucion de los tests unitarios
npm run test:unit

# ejecucion de los tests de integracion
npm run test:integration

# ejecucion de ambos tests
npm run test

# ejecucion de cobertura de codigo y obtencion del reporte (ubicado en folder ./coverage/lcov-report/index.html)
npm run coverage

# ejecucion de checkeo de prettier (code formatter)
npm run prettier:check

# ejecucion de autoformateado de prettier (code formatter)
npm run prettier:format

# ejecucion de checkeo de linter (analisis estatico de codigo)
npm run lint

# ejecucion de formateo de linter (analisis estatico de codigo)
npm run lint:fix

# construccion de imagen docker
npm run docker:build

# ejecucion de imagen docker construida (TODO: dinamizar exposicion de puerto)
npm run docker:run

# compilacion de typescript del proyecto
npm run compile

# ejecucion en ambiente de produccion
npm start
```

## Convención de nombres de endpoints

Debe ser autodescriptivo, el método debe indicar la acción. El formato de endpoint es kebab-case
Ej: 

- [GET] /offices - obtiene todas las offices
- [GET] /offices/{id} - obtiene una office particular
- [POST] /offices - crea una office
- [PUT] /offices/{id} - modifica una office
- [DELETE] /offices/{id} - elimina una oficina particular
- [POST] /service-types - obtiene los tipos de servicio (en este caso se usa post por la cantidad de datos necesarios en el request)

## Distribucion de directorios

> Estructura de directorios, opciones y covención de nombres para el proyecto.

    .
    ├── public                   # Contiene los archivos estáticos para primera pantalla hacia front de open api (swagger)
    ├── src                      # Contiene todo el código de aplicacion.
    │   └── domains              # Contiene definicion de dominios de aplicacion
    |         └── ${domain_name} # Contiene definicion de un dominio especifico
    |                  └── controllers # Contiene interfaz de controlador
    |                  └── routes      # Contiene las rutas definidas para endpoints
    |                  └── services    # Contiene los servicios asociados (casos de uso)
    |  └── infrastructure      # Contiene contenido de infraestructura de aplicacion
    |         └── common       # Contiene elementos comunes transversales al dominio
    |         └── gateways     # Contiene los elementos encargados de realizar la comunicacion externa con clientes
    |         └── middlewares  # Contiene los distintos middlewares de la aplicacion
    |         └── openApi      # Contiene los specs de aplicacion
    |         └── repositories # Contiene la interfaz de comunicacion con repositorios externos
    |         └── routes       # Contiene el centralizador de rutas basado en express/
    |         └── server.ts    # Implementacion de lift de servidor express
    | index.ts                 # Punto de partida de la aplicacion


// ****** Source: build.ts******
import s from 'shelljs';
import config from './tsconfig.build.json';
const outDir = config.compilerOptions.outDir;

s.rm('-rf', outDir);
s.mkdir('-p', `${outDir}/src/infrastructure/openApi`);
s.cp(
  'src/infrastructure/openApi/spec.yaml',
  `${outDir}/src/infrastructure/openApi/spec.yaml`,
);


// ****** Source: nodemon.json******
{
  "execMap": {
    "ts": "ts-node"
  },
  "ignore": ["test/**/*.ts", "test/**/*.spec.ts", ".git", "node_modules"],
  "watch": ["server"],
  "ext": "ts,js,json,yaml,yml"
}


// ****** Source: package.json******
{
  "name": "rest-typescript",
  "version": "1.1.1",
  "description": "ripley-app",
  "main": "index.js",
  "scripts": {
    "prepare": "husky install",
    "start": "node dist/src/index.js",
    "compile": "ts-node build.ts && tsc --p tsconfig.build.json",
    "docker:build": "docker build -t base-project .",
    "docker:run": "docker run --rm -it -p 3000:3000 base-project",
    "dev": "NODE_ENV=local nodemon src/index.ts --ignore test/ --watch| pino-pretty",
    "dev:debug": "nodemon --exec 'node -r ts-node/register --inspect-brk' server/index.ts | pino-pretty",
    "lint": "tsc --noEmit && eslint -c .eslintrc.js '{src, test}/*.{js,ts,tsx}' --quiet",
    "lint:fix": "tsc --noEmit && eslint -c .eslintrc.js '{src, test}/*.{js,ts,tsx}' --quiet --fix",
    "test": "cross-env TZ=UTC jest --runInBand",
    "test:unit": "cross-env TZ=UTC npm test -- --testPathPattern=unit\\.*$",
    "test:unit-ps": "cross-env TZ=UTC npm test -- --testPathPattern=unit/.*$",
    "coverage": "cross-env TZ=UTC npm run test -- --coverage --watchAll=false",
    "test:integration": "cross-env TZ=UTC npm test -- --runInBand --testPathPattern=integration\\.*$",
    "test:integration-ps": "cross-env TZ=UTC npm test -- --runInBand --testPathPattern=integration/.*$",
    "prettier:format": "prettier --write \"**/*.{js,ts,yml,yaml}\"",
    "prettier:check": "prettier --check \"**/*.{js,ts,yml,yaml}\""
  },
  "dependencies": {
    "@hapi/boom": "^7.4.3",
    "axios": "^1.6.3",
    "cls-hooked": "^4.2.2",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "dotenv": "^16.3.1",
    "elastic-apm-node": "^4.5.4",
    "express": "^4.18.2",
    "express-actuator": "^1.8.4",
    "ioredis": "^5.3.2",
    "lodash": "^4.17.21",
    "mathjs": "^12.4.0",
    "moment": "^2.29.1",
    "moment-timezone": "^0.5.28",
    "mongoose": "^8.0.3",
    "pino": "^9.0.0",
    "reflect-metadata": "^0.2.1",
    "swagger-ui-express": "^5.0.0",
    "uuid": "^9.0.1",
    "yamljs": "^0.3.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/cls-hooked": "^4.3.8",
    "@types/compression": "^1.7.5",
    "@types/express-actuator": "^1.8.3",
    "@types/jest": "^29.5.11",
    "@types/node": "^20.10.5",
    "@typescript-eslint/eslint-plugin": "^6.16.0",
    "@typescript-eslint/parser": "^6.16.0",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.2",
    "eslint-plugin-scanjs-rules": "^0.2.1",
    "eslint-plugin-security": "^2.1.0",
    "husky": "^8.0.3",
    "jest": "^29.7.0",
    "mongodb-memory-server": "^9.2.0",
    "nodemon": "^3.0.2",
    "pino-pretty": "^10.3.1",
    "prettier": "^3.1.1",
    "shelljs": "^0.8.5",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "testRegex": ".*\\.test\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "src/**/controllers/*.ts",
      "!src/domains/common/**/*.ts",
      "!src/infrastructure/*.ts",
      "!src/infrastructure/**/*.ts",
      "!src/types/**.ts",
      "!src/types/request/**.ts",
      "!src/index.ts"
    ],
    "coverageDirectory": "coverage",
    "testEnvironment": "node",
    "setupFilesAfterEnv": [
      "<rootDir>/test/jest.setup.ts"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}


// ****** Source: src/domains/common/schemas/Capacity.ts******
import { Schema, Document, model } from 'mongoose';

export interface Capacity extends Document {
  user: string;
  schedule: string;
  stockOffice: string;
  subScheduleId: string;
  warehouse: string;
  oplOffice: string;
  services: string[];
  capacityByDayArray: {
    assigned: number;
    occupied: number;
    active: boolean;
    day: Date;
  }[];
}

const capacityByDaySubschema = new Schema(
  {
    assigned: {
      type: Number,
      default: 0,
      required: true,
    },
    occupied: {
      type: Number,
      default: 0,
      required: true,
    },
    active: {
      type: Boolean,
      default: false,
      required: true,
    },
    day: {
      type: Date,
      required: true,
    },
  },
  { _id: false },
);

const capacitySchema = new Schema(
  {
    user: {
      type: Schema.ObjectId,
      ref: 'User',
      required: true,
    },
    schedule: {
      type: Schema.Types.ObjectId,
      ref: 'Schedule',
      required: true,
    },
    stockOffice: {
      type: Schema.Types.ObjectId,
      ref: 'Office',
      required: false,
    },
    subScheduleId: {
      type: Schema.Types.ObjectId,
      required: false,
    },
    warehouse: {
      type: Schema.Types.ObjectId,
      ref: 'Office',
      required: false,
    },
    oplOffice: {
      type: Schema.Types.ObjectId,
      ref: 'Office',
      required: false,
    },
    services: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Service',
        required: true,
      },
    ],
    capacityByDayArray: [capacityByDaySubschema],
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: (obj, ret) => {
        delete ret._id;
      },
    },
  },
);

export default model('Capacity', capacitySchema);


// ****** Source: src/domains/common/schemas/Cargoskus.ts******
import { Schema, Document, model } from 'mongoose';

export interface Cargosku extends Document {
  code: number;
  shortCode: string;
  name: string;
  price: number;
  region: number;
  countryCode: string;
}

const cargoskuSchema = new Schema({
  code: Number,
  shortCode: String,
  name: String,
  price: Number,
  region: Number,
  countryCode: String,
});

export default model('Cargoskus', cargoskuSchema);


// ****** Source: src/domains/common/schemas/Cluster.ts******
import { Schema, Document, model } from 'mongoose';

export interface Cluster extends Document {
  name: string;
  warehouses: Warehouse[];
}

export interface Warehouse {
  code: number;
  name: string;
}

const clusterSchema = new Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    warehouses: [
      new Schema({
        code: {
          type: Number,
          default: 0,
          required: true,
        },
        name: {
          type: String,
          required: true,
          trim: true,
        },
      }),
    ],
  },
  { timestamps: true },
);

clusterSchema.methods = {
  view(full) {
    const view = {
      id: this.id,
      name: this.name,
      warehouses: this.warehouses,
    };

    return full ? { ...view } : view;
  },
};

export default model('Cluster', clusterSchema);


// ****** Source: src/domains/common/schemas/Commune.ts******
import { Schema, Document, model } from 'mongoose';
import Region from './Region';

export interface Commune extends Document {
  user: string;
  name: string;
  simpleCode: string;
  description: string;
  defaultDispatchOffice: string;
  localities: string[];
  code: string;
  province: string;
  region: string;
}

const communeSchema = new Schema({
  user: {
    type: Schema.ObjectId,
    ref: 'User',
  },
  name: {
    type: String,
    minlength: 3,
    maxlength: 100,
    required: true,
  },
  simpleCode: String,
  description: {
    type: String,
    minlength: 5,
    maxlength: 200,
  },
  defaultDispatchOffice: {
    type: Schema.Types.ObjectId,
    ref: 'Office',
  },
  localities: [
    {
      type: String,
      minlength: 3,
      maxlength: 50,
    },
  ],
  code: {
    type: String,
    minlength: 1,
    maxlength: 20,
  },
  province: {
    type: Schema.Types.ObjectId,
    ref: 'Province',
  },
  region: {
    type: Schema.Types.ObjectId,
    ref: Region,
  },
});

function getIdByCode(code) {
  return this.findOne({ simpleCode: `${code}` }, { _id: 1 }, { lean: true });
}

async function getIdBySimpleCode(simpleCode) {
  return this.find(
    { simpleCode: `${simpleCode}` },
    { _id: 1, name: 1, region: 1 },
    { lean: true },
  ).populate({
    path: 'region',
    options: { lean: true },
    select: { code: 1 },
  });
}

function getNameByCode(code) {
  return this.findOne({ simpleCode: `${code}` }, { name: 1 }, { lean: true });
}

async function getCommuneBySimpleCodeAndRegion({
  simpleCode,
  region,
  country,
}) {
  const query = [
    {
      $match: { simpleCode },
    },
    {
      $lookup: {
        from: 'regions',
        localField: 'region',
        foreignField: '_id',
        as: 'region',
      },
    },
    { $match: { 'region.code': region, 'region.country': country } },
    {
      $project: {
        _id: 1,
        code: 1,
        name: 1,
        region: { code: 1 },
      },
    },
    { $limit: 1 },
  ];
  const [commune] = await this.aggregate(query);
  return commune;
}
communeSchema.statics = {
  ...communeSchema.statics,
  getIdByCode,
  getNameByCode,
  getIdBySimpleCode,
  getCommuneBySimpleCodeAndRegion,
};

export default model('Commune', communeSchema);


// ****** Source: src/domains/common/schemas/Country.ts******
import { Schema, Document, model } from 'mongoose';

export interface Country extends Document {
  name: string;
  description: string;
  isoCode: string;
}

const countrySchema = new Schema({
  name: {
    trim: true,
    type: String,
    unique: true,
  },
  description: {
    type: String,
  },
  isoCode: {
    trim: true,
    type: String,
    unique: true,
  },
});

export default model('Country', countrySchema);


// ****** Source: src/domains/common/schemas/Holiday.ts******
import { Schema, Document, model, Model } from 'mongoose';
import { getNewDate } from '../../../infrastructure/helpers/date';
import moment from 'moment';

// TODO: Revisar los aggregate para optimizacion

export interface Holiday extends Document {
  storeCode: string;
  countryIsoCode: string;
  date: {
    asOPL: {
      tranfer: { date: Date; description: string }[];
      reception: { date: Date; description: string }[];
    };
    asSS: {
      tranfer: { date: Date; description: string }[];
      reception: { date: Date; description: string }[];
    };
    holiday: { date: Date; description: string }[];
  };
}

interface HolidayModel extends Model<Holiday> {
  findHoliday(filter: any): Promise<any>;
  findHolidayVendor(filter: any): Promise<any>;
}

const dateAndDescriptionSchema = new Schema(
  {
    date: {
      type: Date,
    },
    description: {
      type: String,
    },
  },
  { _id: false },
);

const dateArray = { type: [dateAndDescriptionSchema] };

const dateScheduleSubschema = new Schema(
  {
    tranfer: dateArray,
    reception: dateArray,
  },
  { _id: false },
);

const dateSubschema = new Schema(
  {
    asOPL: dateScheduleSubschema,
    asSS: dateScheduleSubschema,
    holiday: dateArray,
  },
  { _id: false },
);

const holidaySchema = new Schema({
  storeCode: {
    type: String,
  },
  countryIsoCode: {
    type: String,
  },
  date: dateSubschema,
});

async function findHoliday({
  storeCode,
  country: countryIsoCode,
  dateRequest = getNewDate(),
  type = 'date.holiday.date',
}) {
  const dateRequestFormatted =
    typeof dateRequest === 'string'
      ? moment(dateRequest, 'DD/MM/YYYY').toDate()
      : dateRequest;
  const timezone =
    countryIsoCode === 'CL' ? 'America/Santiago' : 'America/Lima';
  const query = [
    { $match: { $and: [{ storeCode }, { countryIsoCode }] } }, // search storecode and country
    { $unwind: '$date.holiday' },
    { $match: { [type]: { $gte: dateRequestFormatted } } },
    {
      $group: {
        _id: '$_id', // agroup by id
        dates: {
          $push: {
            // build array dates
            $dateToString: {
              date: `$${type}`,
              format: '%d/%m/%Y',
              timezone: timezone,
            },
          },
        },
      },
    },
    { $sort: { date: 1 } }, // sort global query to asc
    { $project: { _id: 0 } }, // purge response (delete _id)
  ];
  const holidays = await this.aggregate(query); // execute query
  return holidays.reduce(
    (accumulator, value) => [...accumulator, ...value.dates],
    [],
  );
}

async function findHolidayVendor({
  storeCode,
  country: countryIsoCode,
  dateRequest = getNewDate(),
  type = 'date.holiday.date',
}) {
  const dateRequestFormatted =
    typeof dateRequest === 'string'
      ? moment(dateRequest, 'DD/MM/YYYY').toDate()
      : dateRequest;
  const timezone =
    countryIsoCode === 'CL' ? 'America/Santiago' : 'America/Lima';
  const query = [
    { $match: { $and: [{ storeCode }, { countryIsoCode }] } }, // search storecode and country
    { $unwind: '$date.holiday' },
    { $match: { [type]: { $gte: dateRequestFormatted } } },
    {
      $group: {
        _id: '$_id', // agroup by id
        dates: {
          $push: {
            // build array dates
            date: {
              $dateToString: {
                date: `$${type}`,
                format: '%d/%m/%Y',
                timezone: timezone,
              },
            },
            status: '$date.holiday.status',
          },
        },
      },
    },
    { $sort: { date: 1 } }, // sort global query to asc
    { $project: { _id: 0 } }, // purge response (delete _id)
  ];
  const holidays = await this.aggregate(query); // execute query
  return holidays.reduce(
    (accumulator, value) => [...accumulator, ...value.dates],
    [],
  );
}

holidaySchema.statics = {
  ...holidaySchema.statics,
  findHoliday,
  findHolidayVendor,
};

export default model<Holiday, HolidayModel>('Holiday', holidaySchema);


// ****** Source: src/domains/common/schemas/MainRoute.ts******
import { Schema, Document, model, Types } from 'mongoose';
import Office from './Office';
import Country from './Country';
import Commune from './Commune';
import MainZone from './MainZone';
import MainWizard from './MainWizard';
import MainSchedule from './MainSchedule';

export interface MainRoute extends Document {
  mainWizard: string;
  mainSchedule: string;
  mainZone: string;
  lastMile: number;
  volumeMin: object;
  lastMileFormat: object;
  frecuency: number[];
  volumeMax: object;
  unitMeasure: string;
  country: string;
  schedule: object;
  courier: string;
  warehouses: object[];
  courierCode: string;
  courierName: string;
  communesOrDistricts: string[];
  activeCommunesOrDistricts: object[];
}

const mainRouteSchema = new Schema({
  mainWizard: {
    ref: MainWizard,
    type: Schema.Types.ObjectId,
  },
  mainSchedule: {
    ref: MainSchedule,
    type: Schema.Types.ObjectId,
  },
  mainZone: {
    ref: MainZone,
    type: Schema.Types.ObjectId,
  },
  lastMile: Number,
  volumeMin: Object,
  lastMileFormat: Object,
  frecuency: [Number],
  volumeMax: Object,
  unitMeasure: String,
  country: {
    ref: Country,
    type: Schema.Types.ObjectId,
  },
  schedule: Object,
  courier: {
    ref: Office,
    type: Schema.Types.ObjectId,
  },
  warehouses: [Object],
  courierCode: String,
  courierName: String,
  communesOrDistricts: [
    {
      ref: Commune,
      type: Schema.Types.ObjectId,
      index: true,
    },
  ],
  activeCommunesOrDistricts: [Object],
});

function getObjectId() {
  return new Types.ObjectId();
}

function getByCommunesOrDistricts(
  communesOrDistricts,
  withoutCapacity = false,
) {
  if (withoutCapacity) {
    return this.find(
      { communesOrDistricts: { $in: communesOrDistricts } },
      { _id: 0, 'schedule.capacityByDay': 0 },
      { lean: true },
    );
  }
  return this.find(
    { communesOrDistricts: { $in: communesOrDistricts } },
    { _id: 0 },
    { lean: true },
  );
}

async function getCapacity(schedule) {
  return this.findOne(
    { mainSchedule: schedule },
    {
      _id: 1,
      mainWizard: 1,
      mainSchedule: 1,
      'schedule.capacityByDay': 1,
    },
    { lean: true },
  );
}

function getBaseCapacity(mainSchedule) {
  return this.findOne(
    { mainSchedule },
    {
      _id: 0,
      unitMeasure: 1,
      frecuency: 1,
      'schedule.capacityByDay': 1,
      'schedule.capacity': 1,
      'schedule.init': 1,
      'schedule.cutTime': 1,
      'schedule.end': 1,
      'schedule.serviceType': 1,
      'schedule.autoSchedule': 1,
      'schedule.enabledForCheckout': 1,
      'schedule.scheduleType': 1,
    },
    { lean: true },
  );
}

mainRouteSchema.statics.getObjectId = getObjectId;
mainRouteSchema.statics.getCapacity = getCapacity;
mainRouteSchema.statics.getBaseCapacity = getBaseCapacity;
mainRouteSchema.statics.getByCommunesOrDistricts = getByCommunesOrDistricts;

export default model<MainRoute>('MainRoute', mainRouteSchema);


// ****** Source: src/domains/common/schemas/MainSchedule.ts******
import { Schema, Document, model } from 'mongoose';
import Office from './Office';
import MainWizard from './MainWizard';
import MainZone from './MainZone';

const mainScheduleSchema = new Schema({
  name: String,
  courier: {
    ref: Office,
    type: Schema.Types.ObjectId,
  },
  mainWizard: {
    ref: MainWizard,
    type: Schema.Types.ObjectId,
  },
  mainZone: {
    ref: MainZone,
    type: Schema.Types.ObjectId,
  },
});

async function getIdByZone(id, scheduleRange) {
  return this.findOne(
    { mainZone: id, scheduleRange },
    {
      _id: 1,
    },
    { lean: true },
  );
}

mainScheduleSchema.statics.getIdByZone = getIdByZone;

export default model('MainSchedule', mainScheduleSchema);


// ****** Source: src/domains/common/schemas/MainWizard.ts******
import { Schema, model, Document } from 'mongoose';
import Office from './Office';
import Country from './Country';
import Service from './Service';
import Commune from './Commune';

export interface MainWizard extends Document {
  courier: string;
  zones: object[];
  warehouses: object[];
  communesOrDistricts: string[];
  typeOfServices: string[];
  country: string;
}

const mainWizardSchema = new Schema({
  courier: {
    ref: Office,
    type: Schema.Types.ObjectId,
  },
  zones: [Object],
  warehouses: [Object],
  communesOrDistricts: [
    {
      ref: Commune,
      type: Schema.Types.ObjectId,
    },
  ],
  typeOfServices: [
    {
      ref: Service,
      type: Schema.Types.ObjectId,
    },
  ],
  country: {
    ref: Country,
    type: Schema.Types.ObjectId,
  },
});

export default model('MainWizard', mainWizardSchema);


// ****** Source: src/domains/common/schemas/MainZone.ts******
import { Schema, Document, model } from 'mongoose';
import Office from './Office';
import MainWizard from './MainWizard';

export interface MainZone extends Document {
  name: string;
  courier: string;
  mainWizard: string;
  code: number;
}

const mainZoneSchema = new Schema({
  name: String,
  courier: {
    ref: Office,
    type: Schema.Types.ObjectId,
  },
  mainWizard: {
    ref: MainWizard,
    type: Schema.Types.ObjectId,
  },
  code: {
    type: Number,
    default: 0,
  },
});

async function getIdByCode(code, courier) {
  return this.findOne(
    { code, courier },
    {
      _id: 1,
    },
    { lean: true },
  );
}

mainZoneSchema.statics.getIdByCode = getIdByCode;

export default model('MainZone', mainZoneSchema);


// ****** Source: src/domains/common/schemas/Manufacture.ts******
import { Schema, Document, model, Types } from 'mongoose';

export interface Manufacture extends Document {
  warehouse: string;
  sku: string;
  subline: string;
  line: string;
  department: string;
  rules: {
    days: number;
    initExceptDate: string;
    endExceptDate: string;
    exceptDays: number;
  };
}

const rulesSubschema = new Schema(
  {
    days: {
      type: Number,
      index: true,
    },
    initExceptDate: {
      type: String,
      index: true,
    },
    endExceptDate: {
      type: String,
      index: true,
    },
    exceptDays: {
      type: Number,
      index: true,
    },
  },
  { _id: false },
);

const manufacturesSchema = new Schema({
  warehouse: {
    type: Types.ObjectId,
    ref: 'Office',
    required: true,
  },
  sku: {
    type: String,
    index: true,
  },
  subline: {
    type: String,
    index: true,
  },
  line: {
    type: String,
    index: true,
  },
  department: {
    type: String,
    index: true,
  },
  rules: {
    type: rulesSubschema,
    required: true,
  },
});

export default model('Manufacture', manufacturesSchema);


// ****** Source: src/domains/common/schemas/Office.ts******
import { Schema, Document, model } from 'mongoose';

export interface Office extends Document {
  user: string;
  officeCode: number;
  storeCode: string;
  name: string;
  address: string;
  phones: string[];
  type: object;
  identifier: string;
  businessName: string;
  commune: string;
  province: string;
  region: string;
  country: string;
  comments: string;
  parameters: object;
  groupingCriteria: object;
  defaultDispatchOffice: string;
  courierOffice: string;
  isActive: boolean;
  defaultCapacity: string;
  minTerm: number;
  minTermFormat: number;
  internalWorkDays: number;
  exceptionDates: object[];
  stockSourceType?: string;
}

const parametersSubschema1 = new Schema({
  isShop: { type: Boolean, default: false },
  isWarehouse: { type: Boolean, default: false },
  handlePPMInventory: { type: Boolean, default: false },
  handleSchedule: { type: Boolean, default: false },
  handleStock: { type: Boolean, default: false },
  reportStocktoTVI: { type: Boolean, default: false },
  hasPickup: { type: Boolean, default: false },
});

const groupingCriteriaSubschema1 = new Schema({
  dispatchOffice: {
    type: Schema.Types.ObjectId,
    ref: 'Office',
  },

  criticalStockCriteria: {
    type: Schema.Types.ObjectId,
    ref: 'Criteria',
  },

  cargoCriteria: {
    type: Schema.Types.ObjectId,
    ref: 'Criteria',
  },
});

const typeSubschema1 = new Schema({
  isShopOffice: { type: Boolean, default: false },
  isReceptionOffice: { type: Boolean, default: false },
  isStoreOffice: { type: Boolean, default: false },
  isVirtualStoreOffice: { type: Boolean, default: false },
  isShopStoreOffice: { type: Boolean, default: false },
  isProviderOffice: { type: Boolean, default: false },
  isOPLOffice: { type: Boolean, default: false },
  isCourierOffice: { type: Boolean, default: false },
  isIndustrialOffice: { type: Boolean, default: false },
  isSupplierDvr: { type: Boolean, default: false },
  isSupplierDdc: { type: Boolean, default: false },
  isSupplierDvo: { type: Boolean, default: false },
});

const exception = new Schema({
  day: { type: Number },
  month: { type: Number },
  year: { type: Number },
});

const officeSchema = new Schema({
  user: {
    type: Schema.ObjectId,
    ref: 'User',
    required: false,
  },

  officeCode: {
    type: Number,
    required: false,
  },

  storeCode: {
    type: String,
    required: false,
  },

  name: {
    type: String,
    trim: true,
    minlength: 2,
    maxlength: 50,
  },

  address: {
    type: String,
    trim: true,
    maxlength: 150,
  },

  phones: {
    type: [String],
  },

  type: typeSubschema1,

  identifier: {
    type: String,
    maxlength: 100,
  },

  businessName: {
    type: String,
    maxlength: 50,
  },

  commune: {
    type: Schema.Types.ObjectId,
    ref: 'Commune',
  },

  province: {
    type: Schema.Types.ObjectId,
    ref: 'Province',
  },

  region: {
    type: Schema.Types.ObjectId,
    ref: 'Region',
  },

  country: {
    type: Schema.Types.ObjectId,
    ref: 'Country',
  },

  comments: {
    type: String,
  },

  parameters: parametersSubschema1,

  groupingCriteria: groupingCriteriaSubschema1,

  defaultDispatchOffice: {
    type: Schema.Types.ObjectId,
    ref: 'Office',
  },

  courierOffice: {
    type: Schema.Types.ObjectId,
    ref: 'Office',
  },

  isActive: {
    type: Boolean,
    default: false,
    required: false,
  },

  defaultCapacity: {
    type: Schema.Types.ObjectId,
    ref: 'Capacity',
  },

  minTerm: {
    type: Number,
    required: false,
  },

  minTermFormat: {
    type: Number,
    required: false,
  },

  internalWorkDays: {
    type: Number,
    required: false,
  },
  exceptionDates: [exception],
  stockSourceType: {
    type: String,
    required: false,
  },
});

async function getIdByCode(code: string) {
  return this.findOne(
    { code, isActive: true },
    {
      _id: 1,
    },
    { lean: true },
  );
}

async function getWarehouseIdByCode(code: string) {
  return this.findOne(
    { storeCode: { $in: [code] }, isActive: true, isStore: true },
    {
      _id: 1,
      internalWorkDays: 1,
      storeCode: 1,
    },
    { lean: true },
  );
}

officeSchema.statics.getIdByCode = getIdByCode;
officeSchema.statics.getWarehouseIdByCode = getWarehouseIdByCode;

export default model('Office', officeSchema);


// ****** Source: src/domains/common/schemas/OfficeRelationships.ts******
import { Schema, Document, model } from 'mongoose';
import Office from './Office';

export interface OfficeRelationship extends Document {
  warehouse: string;
  relationships: Relationship[];
}

export interface Relationship {
  courier: string;
  label: string;
  transferPeriod: number;
  canTransfer: boolean;
  availableDays: AvailableDays;
}

export interface AvailableDays {
  monday: string;
  tuesday: string;
  wednesday: string;
  thursday: string;
  friday: string;
  saturday: string;
  sunday: string;
}

const availableDays = new Schema(
  {
    monday: { type: String, required: true },
    tuesday: { type: String, required: true },
    wednesday: { type: String, required: true },
    thursday: { type: String, required: true },
    friday: { type: String, required: true },
    saturday: { type: String, required: true },
    sunday: { type: String, required: true },
  },
  { _id: false },
);

const relationship = new Schema({
  courier: {
    ref: Office,
    type: Schema.Types.ObjectId,
  },
  label: { type: String, default: '' },
  transferPeriod: { type: Number, default: 0 },
  canTransfer: { type: Boolean, default: false },
  availableDays: availableDays,
});

const OfficeRelationshipSchema = new Schema(
  {
    warehouse: {
      ref: Office,
      type: Schema.Types.ObjectId,
    },
    relationships: [relationship],
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: (obj, ret) => {
        delete ret._id;
      },
    },
  },
);

export default model<OfficeRelationship>(
  'OfficeRelationship',
  OfficeRelationshipSchema,
);


// ****** Source: src/domains/common/schemas/Region.ts******
import { Schema, Document, model } from 'mongoose';
import Commune from './Commune';
import Country from './Country';

export interface Region extends Document {
  user: string;
  name: string;
  description: string;
  code: string;
  communes: string[];
  provinces: string[];
  country: string;
}

const regionSchema = new Schema({
  user: {
    type: Schema.ObjectId,
    ref: 'User',
    required: true,
  },
  name: {
    type: String,
    minlength: 3,
    maxlength: 50,
    required: true,
    trim: true,
  },
  description: {
    type: String,
    trim: true,
    minlength: 3,
    maxlength: 100,
  },
  code: {
    type: String,
    minlength: 1,
    maxlength: 20,
    trim: true,
    required: true,
  },
  communes: [
    {
      type: Schema.Types.ObjectId,
      ref: Commune,
    },
  ],
  provinces: [
    {
      type: Schema.Types.ObjectId,
      ref: 'Province',
    },
  ],
  country: {
    type: Schema.Types.ObjectId,
    ref: Country,
    required: true,
  },
});

export default model('Region', regionSchema);


// ****** Source: src/domains/common/schemas/Schedule.ts******
import { Schema, Document, model } from 'mongoose';

export interface Schedule extends Document {
  user: string;
  cluster: string;
  active: boolean;
  name: string;
  unitMeasure: string;
  type: {
    isDispatchSchedule: boolean;
    isReceptionSchedule: boolean;
    isStockSchedule: boolean;
    isPickingSchedule: boolean;
    isTransferSchedule: boolean;
    isPickingSupplierSchedule: boolean;
  };
  warehouses: string[];
  oplOffices: string[];
  services: string[];
  capacities: {
    warehouseId: string;
    oplId: string;
    capacityId: string;
    subScheduleId: string;
  }[];
  autogenerate: boolean;
  validityStart: Date;
  validityEnd: Date;
  weekBaseCapacity: {
    monday: number;
    tuesday: number;
    wednesday: number;
    thursday: number;
    friday: number;
    saturday: number;
    sunday: number;
  };
  weekCutTime: {
    monday: string;
    tuesday: string;
    wednesday: string;
    thursday: string;
    friday: string;
    saturday: string;
    sunday: string;
  };
  subSchedulesSupplier: {
    _id: string;
    services: string[];
    name: string;
    weekCutTime: {
      monday: string;
      tuesday: string;
      wednesday: string;
      thursday: string;
      friday: string;
      saturday: string;
      sunday: string;
    };
    weekBaseCapacity: {
      monday: number;
      tuesday: number;
      wednesday: number;
      thursday: number;
      friday: number;
      saturday: number;
      sunday: number;
    };
  }[];
}

const unitMeasures = ['M³', 'Unidades'];

const typeSubschema5 = new Schema({
  _id: { type: String, default: false },
  services: { type: Array, default: false },

  name: { type: String, default: false },

  weekCutTime: { type: Object, default: false },

  weekBaseCapacity: { type: Object, default: false },
});

const typeSubschema4 = new Schema({
  warehouseId: {
    type: Schema.ObjectId,
    ref: 'Office',
    required: false,
  },
  oplId: {
    type: Schema.ObjectId,
    ref: 'Office',
    required: false,
  },
  capacityId: {
    type: Schema.ObjectId,
    ref: 'Capacity',
    required: true,
  },
  subScheduleId: {
    type: Schema.ObjectId,
    required: false,
  },
});

const typeSubschema3 = new Schema(
  {
    isDispatchSchedule: { type: Boolean, default: false },
    isReceptionSchedule: { type: Boolean, default: false },
    isStockSchedule: { type: Boolean, default: false },
    isPickingSchedule: { type: Boolean, default: false },
    isTransferSchedule: { type: Boolean, default: false },
    isPickingSupplierSchedule: { type: Boolean, default: false },
  },
  { _id: false },
);

const capacitySubchema1 = new Schema(
  {
    monday: { type: Number, required: true },
    tuesday: { type: Number, required: true },
    wednesday: { type: Number, required: true },
    thursday: { type: Number, required: true },
    friday: { type: Number, required: true },
    saturday: { type: Number, required: true },
    sunday: { type: Number, required: true },
  },
  { _id: false },
);

const cutTimeSubschema1 = new Schema(
  {
    monday: { type: String, required: true },
    tuesday: { type: String, required: true },
    wednesday: { type: String, required: true },
    thursday: { type: String, required: true },
    friday: { type: String, required: true },
    saturday: { type: String, required: true },
    sunday: { type: String, required: true },
  },
  { _id: false },
);

const scheduleSchema = new Schema(
  {
    user: {
      type: Schema.ObjectId,
      ref: 'User',
      required: true,
    },
    cluster: {
      type: Schema.ObjectId,
      ref: 'Cluster',
      required: false,
    },
    active: {
      type: Boolean,
      default: true,
    },
    name: {
      type: String,
      trim: true,
      required: true,
      minlength: 1,
      maxlength: 200,
    },
    unitMeasure: {
      type: String,
      required: true,
      enum: unitMeasures,
    },
    type: {
      type: typeSubschema3,
      required: true,
    },
    warehouses: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Office',
        required: true,
      },
    ],
    oplOffices: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Office',
        required: true,
      },
    ],
    services: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Service',
        required: true,
      },
    ],
    capacities: [
      {
        type: typeSubschema4,
        required: true,
      },
    ],
    autogenerate: {
      type: Boolean,
      default: false,
    },
    validityStart: {
      type: Date,
      required: true,
    },
    validityEnd: {
      type: Date,
      required: true,
    },
    weekBaseCapacity: {
      type: capacitySubchema1,
      required: true,
    },
    weekCutTime: {
      type: cutTimeSubschema1,
      required: true,
    },
    subSchedulesSupplier: [
      {
        type: typeSubschema5,
        required: false,
      },
    ],
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: (obj, ret) => {
        delete ret._id;
      },
    },
  },
);

export default model('Schedule', scheduleSchema);


// ****** Source: src/domains/common/schemas/Service.ts******
import { Schema, Document, model } from 'mongoose';
import Country from './Country';

export interface Service extends Document {
  code: string;
  description: string;
  maxOcurrence: number;
  slackDays: number;
  isActive: boolean;
  cutTime: object[];
  channelSale: object[];
  country: string;
}

const cutTimeSubschema = new Schema(
  {
    id: { type: Number },
    label: { type: String },
    value: { type: String, default: '00:00' },
  },
  { _id: false },
);

const channelSaleSubschema = new Schema(
  {
    id: { type: Number },
    label: { type: String },
  },
  { _id: false },
);

const serviceSchema = new Schema({
  code: {
    type: String,
    required: true,
    minlength: 1,
  },
  description: {
    type: String,
    minlength: 2,
    maxlength: 100,
  },
  maxOcurrence: {
    type: Number,
    default: 0,
  },
  slackDays: {
    type: Number,
    default: 0,
  },
  isActive: {
    type: Boolean,
    default: false,
  },
  cutTime: [cutTimeSubschema],
  channelSale: [channelSaleSubschema],
  country: {
    type: Schema.Types.ObjectId,
    ref: Country,
  },
});

export default model('Service', serviceSchema);


// ****** Source: src/domains/common/schemas/ShippingRates.ts******
import { Schema, Document, model } from 'mongoose';

export interface ShippingRates extends Document {
  courier: string;
  warehouse: string;
  commune: string;
  countryCode: string;
  size: string;
  service: string;
  channelSale: string;
  rates: RatesSubschema[];
}

export interface RatesSubschema extends Document {
  cost: number;
  price: number;
  daysSince: number;
  cargoSku: number;
}

const ratesSubschema = new Schema(
  {
    cost: Number,
    price: Number,
    daysSince: Number,
    cargoSku: Number,
  },
  {
    _id: false,
  },
);

const shippingRatesSchema = new Schema(
  {
    courier: {
      type: Schema.Types.ObjectId,
      ref: 'Office',
      required: true,
    },
    warehouse: {
      type: Schema.Types.ObjectId,
      ref: 'Office',
      required: true,
    },
    commune: {
      type: Schema.Types.ObjectId,
      ref: 'Commune',
      required: true,
    },
    countryCode: {
      type: String,
      required: true,
    },
    size: {
      type: Schema.Types.ObjectId,
      ref: 'Size',
      required: true,
    },
    service: {
      type: Schema.Types.ObjectId,
      ref: 'Service',
      required: true,
    },
    channelSale: String,
    rates: [ratesSubschema],
  },
  {
    versionKey: false,
  },
);

function getShippingRate(warehouse, courier, commune) {
  return this.find({
    warehouse,
    courier,
    commune,
  })
    .populate({
      path: 'size',
      select: '_id, code',
    })
    .lean();
}

shippingRatesSchema.statics.getShippingRate = getShippingRate;

export default model('Shippingrates', shippingRatesSchema);


// ****** Source: src/domains/common/schemas/Size.ts******
import { Schema, Document, model, Types } from 'mongoose';

export interface Size extends Document {
  name: string;
  description: string;
  code: string;
  cubicCapacityFrom: number;
  cubicCapacityTo: number;
  quantityFactor: number;
  higherEquivalenceFactor: number;
  order: number;
  country: string;
  type: {
    isStandardSize: boolean;
    isMarketplaceSize: boolean;
  };
}

const sizeSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  description: {
    type: String,
  },
  code: {
    type: String,
  },
  cubicCapacityFrom: {
    type: Number,
    required: true,
  },
  cubicCapacityTo: {
    type: Number,
    required: true,
  },
  quantityFactor: {
    type: Number,
    required: true,
  },
  higherEquivalenceFactor: {
    type: Number,
    required: true,
  },
  order: {
    type: Number,
    required: true,
  },
  country: {
    type: Types.ObjectId,
    required: true,
  },
  type: {
    isStandardSize: {
      type: Boolean,
      required: true,
    },
    isMarketplaceSize: {
      type: Boolean,
      required: true,
    },
  },
});

export default model('Size', sizeSchema);


// ****** Source: src/domains/fulfillment/controllers/index.ts******
import { Request, Response, NextFunction } from 'express';
import { boomify } from '@hapi/boom';
import { Controller, Post } from '../../../types/decorators';
import responseManager from '../../../infrastructure/common/responseManager';
import { GetFullfillmentRequestDto } from '../entities/GetFulfillmentDto';
import { fulfillmentCalculation, scheduleCalculator } from '../services/fulfillmentCalculation';
import { scheduleCalculation, scheduleCalculationFulfillment } from '../../schedule/services/scheduleCalculation';

@Controller('/fulfillment')
export default class FulfillmentController {
  @Post('/')
  public fulfillment = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const input: GetFullfillmentRequestDto = request.body;
      const fulfillment = await fulfillmentCalculation(
        input,
        scheduleCalculation,
      );
      responseManager(response, fulfillment);
    } catch (err) {
      next(
        boomify(err, {
          statusCode: 400,
          message: 'Se ha producido un error al crear el fulfillment',
        }),
      );
    }
  };

  @Post('/calculation')
  public calculation = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const input: GetFullfillmentRequestDto = request.body;
      const calculation = await scheduleCalculator(
        input,
        scheduleCalculationFulfillment,
      );
      responseManager(response, calculation);
    } catch (err) {
      next(
        boomify(err, {
          statusCode: 400,
          message: 'Se ha producido un error al obtener el calculo',
        }),
      );
    }
  };
}


// ****** Source: src/domains/fulfillment/entities/GetFulfillmentDto.ts******
interface Request {
  date?: string | Date;
}

export type GetFullfillmentRequestDto = {
  products: ProductFulfillmentDto[];
  dispatchDate: string;
  date: string | Date;
  typeOfServiceId: string;
};

export type ProductFulfillmentDto = {
  request?: Request;
  typeOfServicesFormated: TypeOfServiceFulfillmentDto[];
  typeofServices: TypeOfServiceFulfillmentDto[];
};

export type TypeOfServiceFulfillmentDto = {
  date?: string | Date;
  dates?: string[] | any[];
  slackDays: number;
  bestSchedule: {
    lastMile: number;
  };
  id: string;
};


// ****** Source: src/domains/fulfillment/services/fulfillmentCalculation/findBestMatchedFulfillmentDateToDispatchDate.ts******
import moment from 'moment';
import LogHandler from '../../../../infrastructure/common/handlers/logHandler';

export function findBestMatchedFulfillmentDateToDispatchDate(
  typeOfServiceId,
  scheduleCalculationResults,
  selectedDispatchDate,
  dateFormat,
) {
  const errors = [];
  try {
    for (const { matrix, message } of scheduleCalculationResults) {
      if (message || matrix.message) {
        errors.push(message || matrix.message);
      } else {
        for (const { typeofServices } of matrix) {
          for (const typeOfService of typeofServices) {
            const { id, dates, fulfillmentDates } = typeOfService;

            if (id === typeOfServiceId) {
              const selectedDateFormatted =
                selectedDispatchDate.format(dateFormat);
              const dateFound = dates.find(
                (d) =>
                  moment(d).utc().format(dateFormat) === selectedDateFormatted,
              );

              if (dateFound) {
                let fulfillmentFound = null;

                for (const fulfillmentDate of fulfillmentDates) {
                  fulfillmentFound = fulfillmentDate.find(
                    (secuence) =>
                      secuence.dispatchDay === selectedDateFormatted,
                  );

                  if (fulfillmentFound) {
                    return { fulfillmentDates: fulfillmentDate, errors: [] };
                  }
                }
              }
            }
          }
        }
      }
    }

    return { fulfillmentDates: [], errors };
  } catch (error) {
    LogHandler.warn({
      action: 'FIND_BEST_FULFILLMENT_DATES_ERROR',
      error: error.message,
      stack: error.stack,
    });
    errors.push(error.message);
    return { fulfillmentDates: [], errors };
  }
}


// ****** Source: src/domains/fulfillment/services/fulfillmentCalculation/formatFulfillment.ts******
export const formatFulfillment = (data) => data.map(
  ({ typeofServices }) => ({
    typeofServices: typeofServices.map(
      ({ id, fulfillmentDates }) => ({
        id,
        fulfillmentDates,
      }),
    ),
  }),
);


// ****** Source: src/domains/fulfillment/services/fulfillmentCalculation/index.ts******
import moment from 'moment';
import { cloneDeep } from 'lodash';
import {
  getArrayOfDatesBetween,
  lessDays,
} from '../../../../infrastructure/helpers/date';
import { setNewStartDates } from './setNewStartDates';
import { findBestMatchedFulfillmentDateToDispatchDate } from './findBestMatchedFulfillmentDateToDispatchDate';
import { GetFullfillmentRequestDto } from '../../entities/GetFulfillmentDto';

const DATE_FORMAT = 'DD/MM/YYYY';

export async function fulfillmentCalculation(
  body: GetFullfillmentRequestDto,
  calculator,
) {
  try {
    const { date, dispatchDate, products } = body;

    if (!date || !dispatchDate || !products.length) {
      throw new Error('Faltan datos para calcular el fulfillment');
    }

    const saleDate = moment(date, DATE_FORMAT).utc();
    const selectedDispatchDate = moment(dispatchDate, DATE_FORMAT).utc();
    const [{ slackDays }] = products[0].typeOfServicesFormated;
    const { lastMile } = products[0].typeOfServicesFormated[0].bestSchedule;
    const typeOfServiceId =
      body.typeOfServiceId || products[0].typeOfServicesFormated[0].id;

    const maxDate = lessDays(selectedDispatchDate, Number(slackDays) + Number(lastMile));
    const tentativeStartDates = getArrayOfDatesBetween(saleDate, maxDate);

    const scheduleCalculationPromises = [];
    tentativeStartDates.reverse();
    for (const startDate of tentativeStartDates) {
      let data = cloneDeep(body);
      data = setNewStartDates(data, startDate);
      const promise = calculator(data);
      scheduleCalculationPromises.push(promise);
    }
    const scheduleCalculationResults = await Promise.all(
      scheduleCalculationPromises,
    );

    const { fulfillmentDates, errors } =
      findBestMatchedFulfillmentDateToDispatchDate(
        typeOfServiceId,
        scheduleCalculationResults,
        selectedDispatchDate,
        DATE_FORMAT,
      );

    if (fulfillmentDates?.length === 0) {
      throw new Error(
        errors.join(', ') ||
        'No se pudo optimizar el fulfillment para la fecha de despacho seleccionada',
      );
    }
    return { fulfillmentDates };
  } catch (err) {
    throw new Error(err.message);
  }
}

export async function scheduleCalculator(
  body: GetFullfillmentRequestDto,
  calculator: (data: any) => Promise<any>,
) {
  try {
    const data = setNewStartDates(body, body.date as string);
    const result = calculator(data);
    return result;
  } catch (err) {
    throw new Error(err.message);
  }
}


// ****** Source: src/domains/fulfillment/services/fulfillmentCalculation/setNewStartDates.ts******
import { getArrayOfDatesBetween } from '../../../../infrastructure/helpers/date';
import { GetFullfillmentRequestDto } from '../../entities/GetFulfillmentDto';

export function setNewStartDates(data: GetFullfillmentRequestDto, date: string) {
  data.date = new Date(date);
  data.products.forEach((product) => {
    product.request.date = new Date(date);
    product.typeOfServicesFormated.forEach((typeOfService) => {
      typeOfService.date = new Date(date);
      typeOfService.dates = getArrayOfDatesBetween(
        date,
        typeOfService.dates.length,
        '',
      ).map((d) => new Date(d));
    });
    product.typeofServices = product.typeOfServicesFormated;
  });
  return data;
}


// ****** Source: src/domains/schedule/common/executeFlow.ts******
import { LOG_PROCESS_TIME } from '../../../infrastructure/common/env';
import LogHandler from '../../../infrastructure/common/handlers/logHandler';
import { Timer } from '../../../infrastructure/helpers';

export async function executeFlow(data, ...functions) {
  let res = data;
  const timeLogger = [];
  const flowTimer = new Timer().start('executeFlow');
  for (const func of functions) {
    const functionTimer = new Timer();
    try {
      if (res.ejectFlow) return res.ejectFlowContent;
      functionTimer.start(func.name);
      // eslint-disable-next-line no-await-in-loop
      res = await func(res);
      timeLogger.push(functionTimer.stop());
    } catch (e) {
      timeLogger.push(functionTimer.stop());
      timeLogger.push(flowTimer.stop());
      if (LOG_PROCESS_TIME)
        LogHandler.info({ reqId: data.reqId, flowTimeLog: timeLogger });
      LogHandler.error({
        request: {
          region: data.region,
          commune: data.commune,
          sku: data.products[0].sku,
          country: data.country,
        },
        reqId: data.reqId,
        error: e.message,
        stackTrace: e.stack,
      });
      throw e;
    }
  }
  timeLogger.push(flowTimer.stop());
  if (LOG_PROCESS_TIME)
    LogHandler.info({ reqId: data.reqId, flowTimeLog: timeLogger });
  return res;
}


// ****** Source: src/domains/schedule/common/getOfficeType.ts******
import boom from '@hapi/boom';
import OfficeModel from '../../common/schemas/Office';
import { getCacheClient } from '../../../infrastructure/gateways/cacheClient';
import { getObjectIdFromMongoose } from '../../../infrastructure/helpers/mongoHelper';

export async function getOfficeType(
  warehouseId: string,
  country,
): Promise<any> {
  try {
    const selectedType = {
      stockSourceType: 1,
      type: 1,
      storeCode: 1,
    }
    return getCacheClient().wrapperQuery(
      `${country}-OfficeType-${warehouseId}`,
      async () =>
        OfficeModel.findOne({
          _id: getObjectIdFromMongoose(warehouseId),
        })
          .select(selectedType)
          .lean()
          .exec(),
    );
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/common/getSlackDaysByPriority.ts******
export const getSlackDaysByPriority = (data) => {
  const { hierarchy, courier } = data;
  let slackDaysByPriority = null;
  const hierarchyCascadeRules = [
    {
      // first by subline
      slackDays: hierarchy.subline.slackDays || 0,
      slackCourier: hierarchy.subline.slackCourier || false,
    },
    {
      // then by line
      slackDays: hierarchy.line.slackDays || 0,
      slackCourier: hierarchy.line.slackCourier || false,
    },
    {
      // then by department
      slackDays: hierarchy.department.slackDays || 0,
      slackCourier: hierarchy.department.slackCourier || false,
    },
  ];
  for (const rule of hierarchyCascadeRules) {
    if (
      rule &&
      rule.slackDays > 0 &&
      rule.slackCourier &&
      rule.slackCourier.toString() === courier.toString()
    ) {
      slackDaysByPriority = rule.slackDays;
      break;
    }
  }
  return slackDaysByPriority;
};


// ****** Source: src/domains/schedule/common/hasCapacity.ts******
import moment from 'moment';
import { create, all } from 'mathjs';

const math = create(all, { number: 'BigNumber' });

export async function hasCapacity(date, objCapacity, orderData = {}) {
  const {
    orderVolume = null,
    orderQuantity = null,
    unitMeasure = '',
  } = orderData as any;
  const formatedDate = moment.utc(date).format('DD-MM-YYYY');
  const capacityByDate = objCapacity[formatedDate];
  if (capacityByDate) {
    const { assigned, occupied, active } = capacityByDate;
    switch (unitMeasure) {
      case 'UNIDAD':
        return assigned - occupied >= orderQuantity && active && occupied >= 0;
      case 'M3': {
        const assignedMath = math.bignumber(assigned);
        const occupiedMath = math.bignumber(occupied);
        const availableCapacity = math
          .subtract(assignedMath, occupiedMath)
          .toNumber();
        return availableCapacity >= orderVolume && active && occupied >= 0;
      }
      default:
        return assigned - occupied > 0 && active && occupied >= 0;
    }
  }

  return false;
}


// ****** Source: src/domains/schedule/common/hasCapacityGenericForSchedules.ts******
const { create, all } = require('mathjs');

const math = create(all, { number: 'BigNumber' });

export function hasCapacityGenericForSchedules(
  objCapacity,
  orderData: any = {},
) {
  const {
    orderVolume = null,
    orderQuantity = null,
    unitMeasure = '',
  } = orderData;
  if (objCapacity) {
    const { assigned, occupied, active } = objCapacity;
    const absCapOccupied = Math.abs(occupied);
    switch (unitMeasure) {
      case 'Unidades':
      case 'UNIDAD':
        return assigned - absCapOccupied >= orderQuantity && active;
      case 'M³':
      case 'M3': {
        const assignedMath = math.bignumber(assigned);
        const occupiedMath = math.bignumber(occupied);
        const availableCapacity = math
          .subtract(assignedMath, occupiedMath)
          .toNumber();
        return availableCapacity >= orderVolume && active;
      }
      default:
        return assigned - absCapOccupied > 0 && active;
    }
  }

  return false;
}


// ****** Source: src/domains/schedule/common/logFlow.ts******
export function logFlow(type, functionName, isActive = false) {
  return async (data) => {
    const { products, isWithLog } = data;

    if (!isWithLog) return data;

    for (const product of products) {
      const { typeofServices } = product;
      for (const service of typeofServices) {
        const {
          log = {},
          dates, // id,
        } = service;
        dates.forEach((saleDate, index) => {
          if (!log[index]) {
            log[index] = [];
          }
          log[index] = [
            ...log[index],
            {
              type,
              isActive,
              functionName,
              date: saleDate.getTime(),
            },
          ];
        });
        service.log = log;
      }
    }
    return data;
  };
}


// ****** Source: src/domains/schedule/common/modifyDataSchedules.ts******
import { dayBetween } from '../../../infrastructure/helpers/date';

export function modifyDataSchedules(
  data,
  typeofServices,
  pickingSchedules,
  newData,
  dates,
  initialDates,
) {
  data.addedDays += dayBetween(initialDates[0], dates[0]);
  typeofServices.dates = [...dates];
  pickingSchedules.push(newData);
}


// ****** Source: src/domains/schedule/common/scheduleTypeOfServices.ts******


// ****** Source: src/domains/schedule/common/typeOfServicesFunctions.ts******
import boom from '@hapi/boom';
import { getCacheClient } from '../../../infrastructure/gateways/cacheClient';
import { ScheduleErrors } from '../../shipping/entities/constants';
import { getOfficeType } from './getOfficeType';
import ClusterModel from '../../common/schemas/Cluster';
import Schedule from '../../common/schemas/Schedule';
import Capacity from '../../common/schemas/Capacity';
import {
  addDays,
  checkExceptDays,
  checkRoute,
  dateDiff,
  isSameOrAfter,
} from '../../../infrastructure/helpers/date';
import moment from 'moment';
import { validDay } from './validDay';
import Office from '../../common/schemas/Office';
import { create, all } from 'mathjs';
import OfficeRelationships from '../../common/schemas/OfficeRelationships';
import { getObjectIdFromMongoose } from '../../../infrastructure/helpers/mongoHelper';

const math = create(all, { number: 'BigNumber' });

export async function scheduleTypeOfServices(
  typeOfService,
  country,
  transfer,
  orderData,
  withRoute,
  indirect = false,
  warehouseObj,
  courierId,
  couriercode,
  relation,
  schedulesToConsume = {} as any,
) {
  const { bestSchedule, date, id } = typeOfService;
  let { courier, warehouse, courierCode } = bestSchedule;

  if (indirect) {
    courier = courierId;
    warehouse = warehouseObj;
    courierCode = couriercode;
  }

  if (warehouse.storeId !== courier || indirect) {
    const isDirect = await directRelationTransfer(
      bestSchedule,
      transfer,
      country,
    );
    const checkDestinationType: any = await checkOfficeType(courier, country);
    if (isDirect || (indirect && checkDestinationType)) {
      const selectedCluster = await getClusterWarehouse(courierCode, country);
      if (selectedCluster) {
        const [transferSchedule]: any = await getScheduleTransNoCache(
          warehouse.storeId,
          id,
          selectedCluster._id,
        );
        if (transferSchedule) {
          const transferScheduleData = objectScheduleTransfer();
          const { capacityId } = transferSchedule.capacities.find(
            ({ warehouseId }) => warehouseId.toString() === warehouse.storeId,
          );
          schedulesToConsume.transferSchedules.push({
            capacityId,
            ...formatTransferScheduleToConsume(transferSchedule, warehouse),
          });
          const [transferCapacity] = await getCapacityById(capacityId);
          await getCapacityByTypeSchedule(
            typeOfService,
            transferScheduleData,
            transferSchedule,
            transferCapacity,
            orderData,
            date,
            'TRANSFERENCIA',
            withRoute,
            false,
            country,
            indirect,
            relation,
            warehouseObj,
            courierId,
            couriercode,
          );
        } else {
          const relationLabel =
            relation && Object.keys(relation).length > 0
              ? relation.label
              : 'no existe relación para agenda de transferencia';
          throw new Error(
            `${ScheduleErrors.NoScheduleCapacity} ${relationLabel}`,
          );
        }
      } else {
        throw new Error(
          `${ScheduleErrors.NoClusterOpl} ${checkDestinationType.storeCode} - ${checkDestinationType.name}`,
        );
      }
    }
  }
}

export async function receptionTypeOfServices(
  typeOfService,
  country,
  transfer,
  orderData,
  exceptDays,
  indirect = false,
  warehouseObj = '',
  courierId = '',
  couriercode = '',
  relation = [] as any,
  schedulesToConsume = {} as any,
) {
  const { bestSchedule, date, id } = typeOfService;
  let { courier, warehouse, courierCode } = bestSchedule;
  if (indirect) {
    courier = courierId;
    warehouse = warehouseObj;
    courierCode = couriercode;
  }
  if (warehouse.storeId !== courier || indirect) {
    const isDirect = await directRelationTransfer(
      bestSchedule,
      transfer,
      country,
    );
    const checkDestinationType = await checkOfficeType(courier, country);

    if (isDirect || (indirect && checkDestinationType)) {
      const [receptionSchedule]: any = await getScheduleReceptionNoCache(
        courier,
        id,
      );
      if (receptionSchedule) {
        const receptionScheduleData = objectScheduleTransfer();
        const { capacityId } = receptionSchedule.capacities.find(
          ({ oplId }) => oplId.toString() === courier,
        );
        schedulesToConsume.receptionSchedules.push({
          capacityId,
          ...formatReceptionScheduleToConsume(
            receptionSchedule,
            courier,
            courierCode,
          ),
        });
        // eslint-disable-next-line no-await-in-loop
        const [transferCapacity] = await getCapacityById(capacityId);
        if (transferCapacity) {
          await getCapacityByTypeSchedule(
            typeOfService,
            receptionScheduleData,
            receptionSchedule,
            transferCapacity,
            orderData,
            date,
            'RECEPCION',
            false,
            exceptDays,
            country,
            indirect,
            relation,
            warehouse,
            courier,
            courierCode,
          );
        }
        if (!indirect) typeOfService.receptionDates = typeOfService.dates;
      } else {
        throw new Error(
          `${ScheduleErrors.NoScheduleReception}  ${
          // TODO: revisar tipo de dato de "relation", default es un array vacio [] pero aqui se accede como si fuera objeto
          relation ? relation.label : courierCode
          }`,
        );
      }
    }
  }
}

async function directRelationTransfer(bestSchedule, transferData, country) {
  if (
    transferData &&
    transferData.length === 2 &&
    bestSchedule.warehouse.storeId === transferData[0].id &&
    transferData[1].id === bestSchedule.courier
  ) {
    return checkOfficeType(transferData[1].id, country);
  }
  return false;
}

async function checkOfficeType(destination, country) {
  const secondOffice = await getOfficeType(destination, country);
  if (secondOffice.stockSourceType) {
    return secondOffice;
  }
  return false;
}

async function getClusterWarehouse(courierCode, country) {
  const clusters = await getCluster(country);
  if (clusters) {
    for (const cluster of clusters) {
      const { warehouses } = cluster;
      const picked = warehouses.filter(
        (warehouse) => warehouse.code.toString() === courierCode,
      );
      if (picked.length > 0) {
        return cluster;
      }
    }
  }
  return false;
}

export async function getCluster(country) {
  try {
    return getCacheClient().wrapperQuery(`${country}-Clusters`, async () =>
      ClusterModel.where({} as any, { isStore: 1 })
        .lean()
        .exec(),
    );
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function getScheduleTransNoCache(warehouse, service, cluster) {
  try {
    return await Schedule.find(
      {
        warehouses: { $in: [getObjectIdFromMongoose(warehouse)] },
        cluster: getObjectIdFromMongoose(cluster),
        'type.isTransferSchedule': true,
        services: { $in: [getObjectIdFromMongoose(service)] },
      },
      { createdAt: 0, updatedAt: 0 },
    )
      .lean()
      .exec();
  } catch (err) {
    throw boom.boomify(err);
  }
}

function objectScheduleTransfer() {
  return {
    typeOfServices: [],
    scheduleId: null,
    capacityId: null,
    warehouseId: null,
    unitMeasure: null,
    weekCutTime: null,
    capacityByDayArray: null,
  };
}

const formatTransferScheduleToConsume = (schedule, warehouse) => {
  const { unitMeasure, services } = schedule;
  const { storeId, storeCode } = warehouse;
  return {
    unitMeasure,
    warehouseId: storeId,
    typeOfServices: services,
    warehouseCode: storeCode,
  };
};

async function getCapacityById(capacityId) {
  try {
    return await Capacity.find(
      { _id: capacityId },
      { _id: 1, capacityByDayArray: 1 },
      {},
    )
      .lean()
      .exec();
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function getCapacityByTypeSchedule(
  typeOfService,
  transferScheduleData,
  transferSchedule,
  transferCapacity,
  orderData,
  date,
  typeSchedule,
  withRoute,
  withExcept,
  country,
  indirect,
  relation,
  warehouseObj = '',
  courierId = '',
  couriercode = '',
) {
  try {
    const { bestSchedule, dates, holidays = {}, id } = typeOfService;
    let { courier, warehouse, courierCode } = bestSchedule;
    if (indirect) {
      courier = courierId;
      warehouse = warehouseObj;
      courierCode = couriercode;
    }
    const { storeCode, storeName, storeId } = warehouse;
    let isExcept,
      checkedCapacity,
      isRoute = false;
    const hourFormat = 'hh:mm';
    const dayNameFormat = 'dddd';
    getTransfer(
      transferScheduleData,
      warehouse,
      transferSchedule,
      transferCapacity,
      orderData,
    );
    const [except] = await getOfficeExceptDays(storeId, country);
    const holidaysIndex = relation?.code ? relation.code : storeCode;

    for (let dateIndex = 0; dateIndex < dates.length; dateIndex++) {
      let newDate = dates[dateIndex];
      let counterDays =
        0 +
        dateDiff(
          await validDay(newDate, holidays[holidaysIndex]),
          dates[dateIndex],
        );
      for (const capacityByDay of transferCapacity.capacityByDayArray) {
        const capacity = capacityByDay;
        // if consulted day is same or after
        if (isSameOrAfter(capacity.day, newDate, 'day')) {
          let isChecked = true;
          // set current weekCutime
          const weekCutTime =
            transferSchedule.weekCutTime[
            moment(capacity.day).format(dayNameFormat).toLowerCase()
            ];
          if (
            newDate === date && // check cuttime in first date
            moment(date, hourFormat).isAfter(moment(weekCutTime, hourFormat))
          ) {
            newDate = addDays(newDate, 1);
            counterDays += 1;
            isChecked = false;
          }
          const hasCapacity = hasCapacityGenericForSchedules(
            capacity,
            orderData,
          );
          if (withRoute) {
            isRoute = await validateRoute(warehouse, newDate, courier);
          }
          if (withExcept) {
            isExcept = await isNotExceptDay(newDate, except);
          }
          if (
            !hasCapacity ||
            (withRoute && !isRoute) ||
            (withExcept && !isExcept)
          ) {
            if (isChecked) {
              newDate = new Date(addDays(newDate, 1));
              counterDays += 1;
            }
          } else {
            // capacity found
            newDate = new Date(capacity.day);
            checkedCapacity = true;
            if (indirect && typeSchedule === 'TRANSFERENCIA') {
              if (withRoute) {
                const { transferDateTrf = [], transferDateTrfDays = [] } =
                  relation;
                relation.transferDateTrf = [...transferDateTrf, newDate];
                relation.transferDateTrfDays = [
                  ...transferDateTrfDays,
                  counterDays,
                ];
              } else {
                const {
                  transferScheduleDate = [],
                  transferScheduleDateDays = [],
                } = relation;
                relation.transferScheduleDate = [
                  ...transferScheduleDate,
                  newDate,
                ];
                relation.transferScheduleDateDays = [
                  ...transferScheduleDateDays,
                  counterDays,
                ];
              }
            }
            if (indirect && typeSchedule !== 'TRANSFERENCIA') {
              if (withExcept) {
                const {
                  receptionExceptDate = [],
                  receptionExceptDateDays = [],
                } = relation;
                relation.receptionExceptDate = [
                  ...receptionExceptDate,
                  newDate,
                ];
                relation.receptionExceptDateDays = [
                  ...receptionExceptDateDays,
                  counterDays,
                ];
              } else {
                const {
                  receptionSchedule = [],
                  receptionScheduleDateDays = [],
                } = relation;
                relation.receptionSchedule = [...receptionSchedule, newDate];
                relation.receptionScheduleDateDays = [
                  ...receptionScheduleDateDays,
                  counterDays,
                ];
              }
            }
            dates[dateIndex] = newDate;
            break;
          }
        }
      }
    }

    transferScheduleData.typeOfServices = [
      ...transferScheduleData.typeOfServices,
      { serviceId: id, firstDate: dates[0] },
    ];

    if (!checkedCapacity) {
      if (typeSchedule === 'TRANSFERENCIA')
        throw new Error(
          `${ScheduleErrors.NoScheduleWarehouse} ${storeCode} - ${storeName}`,
        );
      throw new Error(
        `${ScheduleErrors.NoScheduleReceptionCapacity} ${courierCode}`,
      );
    }
    typeOfService.dates = dates;
  } catch (err) {
    throw boom.boomify(err);
  }
}

function getTransfer(
  transferScheduleData,
  warehouse,
  transferSchedule,
  transferCapacity,
  orderData,
) {
  transferScheduleData.warehouseId = warehouse.storeId;
  transferScheduleData.scheduleId = transferSchedule._id;
  transferScheduleData.capacityId = transferCapacity._id;
  transferScheduleData.unitMeasure = transferSchedule.unitMeasure;
  if (transferScheduleData.unitMeasure === 'Unidades') {
    orderData.unitMeasure = 'UNIDAD';
  } else {
    orderData.unitMeasure = 'M3';
  }
  transferScheduleData.weekCutTime = transferSchedule.weekCutTime;
  transferScheduleData.capacityByDayArray = transferCapacity.capacityByDayArray;
  return transferScheduleData;
}

async function getOfficeExceptDays(warehouseId, country) {
  try {
    return getCacheClient().wrapperQuery(
      `${country}-OfficeExceptDays-${warehouseId}`,
      async () =>
        Office.find(
          {
            _id: getObjectIdFromMongoose(warehouseId),
          },
          { exceptionDates: 1 },
        )
          .lean()
          .exec(),
    );
  } catch (err) {
    throw boom.boomify(err);
  }
}

function hasCapacityGenericForSchedules(objCapacity, orderData = {} as any) {
  const {
    orderVolume = null,
    orderQuantity = null,
    unitMeasure = '',
  } = orderData;
  if (objCapacity) {
    const { assigned, occupied, active } = objCapacity;
    const absCapOccupied = Math.abs(occupied);
    switch (unitMeasure) {
      case 'Unidades':
      case 'UNIDAD':
        return assigned - absCapOccupied >= orderQuantity && active;
      case 'M³':
      case 'M3': {
        const assignedMath = math.bignumber(assigned);
        const occupiedMath = math.bignumber(occupied);
        const availableCapacity = math
          .subtract(assignedMath, occupiedMath)
          .toNumber();
        return availableCapacity >= orderVolume && active;
      }
      default:
        return assigned - absCapOccupied > 0 && active;
    }
  }

  return false;
}

async function validateRoute(warehouse, date, courier) {
  const officeRelationships = await getOfficeRelationNoRedis(warehouse.storeId);
  if (!officeRelationships || officeRelationships.length === 0)
    throw new Error(
      `${ScheduleErrors.NoRoute} ${warehouse.storeId} - ${warehouse.storeName}`,
    );
  const [{ relationships = [] }] = officeRelationships;
  if (!relationships || relationships.length === 0)
    throw new Error(`${ScheduleErrors.NoTransfer}`);
  const { availableDays } =
    relationships.find((x) => x.courier.toString() === courier) || {};
  return availableDays ? checkRoute(date, availableDays) : null;
}

async function getOfficeRelationNoRedis(warehouseId) {
  try {
    return await OfficeRelationships.find(
      { warehouse: getObjectIdFromMongoose(warehouseId) },
      { createdAt: 0, updatedAt: 0 },
    )
      .lean()
      .exec();
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function isNotExceptDay(newDate, exceptObject) {
  if (exceptObject) {
    const { exceptionDates } = exceptObject;
    const isExceptDay = checkExceptDays(newDate, exceptionDates);
    return !isExceptDay;
  }
  return true;
}

async function getScheduleReceptionNoCache(warehouse, service) {
  try {
    // TODO: revisar query
    return await Schedule.where(
      {
        oplOffices: { $in: [getObjectIdFromMongoose(warehouse)] },
        'type.isReceptionSchedule': true,
        services: { $in: [getObjectIdFromMongoose(service)] },
      } as any,
      { createdAt: 0, updatedAt: 0 },
    )
      .lean()
      .exec();
  } catch (err) {
    throw boom.boomify(err);
  }
}

const formatReceptionScheduleToConsume = (schedule, courier, courierCode) => {
  const { unitMeasure, services } = schedule;
  return {
    unitMeasure,
    courierId: courier,
    courierCode: courierCode,
    typeOfServices: services,
  };
};


// ****** Source: src/domains/schedule/common/validDay.ts******
import boom from '@hapi/boom';
import {
  addDays,
  getDDMMYYYYByDate,
  isBetween,
} from '../../../infrastructure/helpers/date';
import { hasCapacity } from './hasCapacity';

export async function validDay(
  date,
  holidays = [],
  frequency = [],
  capacity = {},
  firstDateCapacity = null,
  lastDateCapacity = null,
  orderData = {},
) {
  let newDate = date;
  const dateWithOutHour = getDDMMYYYYByDate(date);
  let isChange = false;
  try {
    if (holidays.length > 0 && holidays.includes(dateWithOutHour)) {
      newDate = addDays(newDate, 1);
      isChange = true;
    }

    if (frequency.length > 0 && !frequency.includes(newDate.getDay())) {
      newDate = addDays(newDate, 1);
      isChange = true;
    }

    if (Object.keys(capacity).length > 0) {
      const isBetweenNewDate = isBetween(
        newDate,
        firstDateCapacity,
        lastDateCapacity,
      );
      const isCapacity = await hasCapacity(newDate, capacity, orderData);
      if (isBetweenNewDate && !isCapacity) {
        newDate = addDays(newDate, 1);
        isChange = true;
      }
    }
    newDate.setHours(date.getHours(), date.getMinutes());
    return isChange
      ? await validDay(
          newDate,
          holidays,
          frequency,
          capacity,
          firstDateCapacity,
          lastDateCapacity,
          orderData,
        )
      : newDate;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/controllers/index.ts******
import { Request, Response, NextFunction } from 'express';
import { boomify } from '@hapi/boom';
import { Controller, Post } from '../../../types/decorators';
import { getSimulatorUnit } from '../services';
import responseManager, {
  simulatorResponseManager,
} from '../../../infrastructure/common/responseManager';
import { SimulatorReloadRequestDto } from '../entities/SimulatorReloadRequestDto';
import { ScheduleCalculationRequestDto } from '../entities/ScheduleCalculationRequestDto';
import { getScheduleCalculation } from '../services/getScheduleCalculation';

@Controller('/schedule')
export default class ScheduleController {
  @Post('/simulator/simple/reload')
  public simulatorReload = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const input: SimulatorReloadRequestDto = request.body;
      const { matrix } = await getSimulatorUnit(input);
      simulatorResponseManager(response, matrix);
    } catch (err) {
      next(
        boomify(err, {
          statusCode: 400,
        }),
      );
    }
  };

  @Post('/calculation')
  public scheduleCalculation = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const input: ScheduleCalculationRequestDto = request.body;
      const { matrix } = await getScheduleCalculation(input);
      responseManager(response, matrix);
    } catch (err) {
      next(
        boomify(err, {
          statusCode: 400,
        }),
      );
    }
  };
}


// ****** Source: src/domains/schedule/entities/ScheduleCalculationRequestDto.ts******
export type ScheduleCalculationRequestDto = {
  products: ProductCalculationDto[];
  country: string;
};

type ProductCalculationDto = {
  request: RequestDto;
  regionData: RegionDataDto;
  deliveryId: string;
  serviceData: ServiceDataDto[];
  localityData: LocalityDataDto;
  skuData: SkuDataDto;
  stockData: StockDataDto[];
  bestSchedules: BestScheduleDto[];
  availableDeliveries: string[];
  typeOfServicesFormated: TypeOfServiceFormatedDto[];
};

type RequestDto = {
  sku: string;
  quantity: number;
  country: string;
  localityCode: string;
  isLegacyRequest: boolean;
  deliveryMethod: string;
  pickupStoreCode: string;
  date: string;
  channelSale: string;
  checkStock: boolean;
};

type RegionDataDto = {
  _id: string;
  name: string;
  code: string;
};

type ServiceDataDto = {
  maxOcurrence: number;
  slackDays: number;
  _id: string;
  enabledForCheckout: boolean;
  code: string;
  cutTime: CutTimeDto[];
  description: string;
  channelSale: ChannelSaleDto[];
  delivery: DeliveryDto;
  country: {
    _id: string;
  };
  typeOfServices: string[];
  serviceGroup?: string;
};

type CutTimeDto = {
  value: string;
  id: number;
  label: string;
};

type ChannelSaleDto = {
  id: number;
  label: string;
};

type DeliveryDto = {
  _id: string;
  code: string;
  description: string;
  creationDate: string;
  __v: number;
};

type LocalityDataDto = {
  _id: string;
  name: string;
  code: string;
  region: string;
};

type SkuDataDto = {
  _id: string;
  code: number;
  name: string;
  description: string;
  shortCode: number;
  height: number;
  width: number;
  length: number;
  parents: ParentsDto;
  hierarchy: HierarchyDto;
  size: string;
  sizeName: string;
  sizeId: string;
  hierarchies: string[];
  volume: number;
};

type ParentsDto = {
  department: string;
  line: string;
  subline: string;
};

type HierarchyDto = {
  department: DepartmentDto;
  line: LineDto;
  subline: SublineDto;
};

type DepartmentDto = {
  _id: string;
  code: string;
  name: string;
  slackDays: number;
  size: SizeDto;
};

type LineDto = {
  _id: string;
  code: string;
  name: string;
};

type SublineDto = {
  _id: string;
  code: string;
  name: string;
  slackDays: number;
  size: SizeDto;
};

type SizeDto = {
  _id: string;
  name: string;
  code: string;
};

type StockDataDto = {
  warehouse: string;
  availableQuantity: number;
  satisfies: boolean;
};

type BestScheduleDto = {
  _id: string;
  volumeMin: VolumeDto;
  volumeMax: VolumeDto;
  courierCode: string;
  courier: string;
  warehouse: WarehouseDto;
  priorityByHierarchy: PriorityByHierarchyDto;
  mainWizard?: string;
  mainSchedule?: string;
  mainZone?: string;
  lastMile?: number;
  lastMileFormat?: {
    id: number;
    label: string;
  };
  frecuency?: number[];
  unitMeasure?: string;
  courierName?: string;
  activeCommunesOrDistricts?: ActiveCommunesOrDistrictsDto[];
  country?: string;
  relations?: RelationDto[];
  schedule?: ScheduleDto;
};

type ScheduleDto = {
  typeofServices: TypeOfServiceDto[];
  capacity: CapacityDto[];
  init: string;
  end: string;
};

type TypeOfServiceDto = {
  id: string;
  code: string;
  label: string;
  cutTime: CutTimeDto[];
  isActive: boolean;
  delivery: DeliveryDto | string;
  description: string;
  slackDays: number;
  channelSale: ChannelSaleDto[];
  maxOcurrence: number;
};

type CapacityDto = {
  id: number;
  label: string;
  value: string | number;
};

type RelationDto = {
  sequence: number;
  id: string;
  courier: string;
  internalWorkDays: number;
  label: string;
  code: string;
  transferPeriod?: number;
};

type ActiveCommunesOrDistrictsDto = {
  id: string;
  label: string;
  isActive: boolean;
};

type VolumeDto = {
  id: string;
  label: string;
  code: string;
  country: string;
  cubicCapacityFrom: number;
  cubicCapacityTo: number;
  isDisabledEdit: boolean;
  order: number;
  quantityFactor: number;
  higherEquivalenceFactor: number;
};

type WarehouseDto = {
  storeCode: string;
  storeId: string;
  storeType: string;
  storeName?: string;
  isValid?: boolean;
  typeofServices?: string[];
  channelSalesCode?: string[];
};

type PriorityByHierarchyDto = {
  typeOfServiceName: string;
  hierarchyName: string;
  hierarchyCode: string;
  priority: number;
};

type TypeOfServiceFormatedDto = {
  id: string;
  code: string;
  label: string;
  cutTime: CutTimeDto[];
  isActive: boolean;
  delivery: DeliveryDto;
  description: string;
  slackDays: number;
  channelSale: ChannelSaleDto[];
  maxOcurrence: string;
  enabledForCheckout: boolean;
  isSyncWithBigticket: boolean;
  serviceGroup: string;
  date: string;
  dates: string[];
  bestSchedule: BestScheduleDto;
};


// ****** Source: src/domains/schedule/entities/SimulatorReloadRequestDto.ts******
import { Product } from '../../shipping/entities/Product';

export type SimulatorReloadRequestDto = {
  products: Product[];
  channelSales: string;
  stock: number;
  date: string;
  hour: string;
  country: string;
  localityCode: string;
  deliveryMethod: string;
  warehouse: string | null;
  courier: string | null;
  typeOfServiceCode: string | null;
  commune: string;
};


// ****** Source: src/domains/schedule/exceptions/DateOutOfRangeException.ts******
import BaseError from '../../../infrastructure/common/exceptions/BaseError';

const code = 'BAD_REQUEST_ERROR';
const name = 'BadRequestException';
const baseMessage = 'Date is out of range';
const status = 400;

export default class DateOutOfRangeException extends BaseError {
  constructor() {
    super(baseMessage, {
      code,
      name,
      baseMessage,
      status,
      details: {},
    });
    Object.setPrototypeOf(this, DateOutOfRangeException.prototype);
  }
}


// ****** Source: src/domains/schedule/exceptions/LocationNotFoundException.ts******
import BaseError from '../../../infrastructure/common/exceptions/BaseError';

const code = 'BAD_REQUEST_ERROR';
const name = 'BadRequestException';
const baseMessage = 'Location not found';
const status = 400;

export default class LocationNotFoundException extends BaseError {
  constructor() {
    super(baseMessage, {
      code,
      name,
      baseMessage,
      status,
      details: {},
    });
    Object.setPrototypeOf(this, LocationNotFoundException.prototype);
  }
}


// ****** Source: src/domains/schedule/exceptions/ProductsNotFoundException.ts******
import BaseError from '../../../infrastructure/common/exceptions/BaseError';

const code = 'BAD_REQUEST_ERROR';
const name = 'BadRequestException';
const baseMessage = 'Products array from input is empty';
const status = 400;

export default class ProductsNotFoundException extends BaseError {
  constructor() {
    super(baseMessage, {
      code,
      name,
      baseMessage,
      status,
      details: {},
    });
    Object.setPrototypeOf(this, ProductsNotFoundException.prototype);
  }
}


// ****** Source: src/domains/schedule/exceptions/ServicesNotFoundException.ts******
import BaseError from '../../../infrastructure/common/exceptions/BaseError';

const code = 'BAD_REQUEST_ERROR';
const name = 'BadRequestException';
const baseMessage = 'Type of services not found.';
const status = 400;

export default class ServicesNotFoundException extends BaseError {
  constructor() {
    super(baseMessage, {
      code,
      name,
      baseMessage,
      status,
      details: {},
    });
    Object.setPrototypeOf(this, ServicesNotFoundException.prototype);
  }
}


// ****** Source: src/domains/schedule/services/buildData.ts******
import { CONFIG_KEY } from '../../../infrastructure/common/env';
import { getTrackId } from '../../../infrastructure/common/handlers/traceHandler';
import { addDecimals, multiplyDecimals } from '../../../infrastructure/helpers';
import { getDateUtc, getNewDate } from '../../../infrastructure/helpers/date';
import { DeliveryMethods, ServiceKey } from '../../shipping/entities/constants';

export function buildData(
  body,
  products,
  country,
  channelSales,
  hour,
  withLog = false,
) {
  let orderVolume = 0;
  let orderQuantity = 0;
  const data = {
    hour: hour,
    date: body.date || getNewDate(),
    schedule: body.schedule,
    commune: body.commune,
    district: body.district,
    orderData: {
      orderVolume: 0,
      orderQuantity: 0,
    },
    products: products.map((p) => {
      orderQuantity += p.request.quantity;
      orderVolume = addDecimals(
        orderVolume,
        multiplyDecimals(p.skuData.volume, p.request.quantity),
      );
      p.slackDays = p.skuData.slackDays;
      p.hierarchy = p.skuData.hierarchy;
      p.slackCourier = p.skuData.slackCourier;
      p.typeofServices = p.typeOfServicesFormated.map((tos) => {
        tos.date = getDateUtc(tos.date);
        tos.dates = tos.dates.map((d) => getDateUtc(d));
        return tos;
      });
      p.schedulesToConsume = {
        transferSchedules: [],
        receptionSchedules: [],
        pickingSchedule: [],
        pickingSupplierSchedule: [],
      };
      return p;
    }),
    app: { country, channel: channelSales },
    country,
    reqId: getTrackId(),
    addedDays: 0,
    isWithCalculationForMixedOrder:
      isWithCalculationForDeliveryMethods(products),
    isPdp: CONFIG_KEY === ServiceKey.PDP,
    isWithLog: withLog,
  };
  data.orderData = {
    orderVolume,
    orderQuantity,
  };
  return data;
}

const isWithCalculationForDeliveryMethods = (products) => {
  const isStorePickup = products.some(
    (p) =>
      p.request.deliveryMethod === DeliveryMethods.StorePickup &&
      p.isConsolidatedByWarehouse === false,
  );
  return isStorePickup && products.length > 1;
};


// ****** Source: src/domains/schedule/services/getScheduleCalculation/index.ts******
import boom from '@hapi/boom';
import { buildData } from '../buildData';
import { scheduleCalculationForMixedOrder } from './scheduleCalculationForMixedOrder';
import { scheduleCalculation } from '../scheduleCalculation';
import { formatMatrixError } from '../../../../infrastructure/helpers/schedule';

export async function getScheduleCalculation(body) {
  const { products = [], country } = body;

  if (products.length === 0) {
    throw boom.badRequest('No se ha encontrado productos');
  }

  const data = buildData(body, products, country, 'TVI', undefined);

  if (data.isWithCalculationForMixedOrder)
    return scheduleCalculationForMixedOrder(data);

  // consulta al calculo de matrix
  const requestToMatrix = await (async () => {
    try {
      return await scheduleCalculation(data);
    } catch (error) {
      return error;
    }
  })();

  // si matrix tiene error, se retorna error al checkout
  if (requestToMatrix?.message) return formatMatrixError(data, requestToMatrix);

  return requestToMatrix;
}


// ****** Source: src/domains/schedule/services/getScheduleCalculation/scheduleCalculation.ts******


// ****** Source: src/domains/schedule/services/getScheduleCalculation/scheduleCalculationForMixedOrder.ts******
import { max, uniqBy } from 'lodash';
import { formatMatrixError } from '../../../../infrastructure/helpers/schedule';
import { DeliveryMethods } from '../../../shipping/entities/constants';
import { scheduleCalculation } from '../scheduleCalculation';
import { fulfillmentBuild } from '../scheduleCalculation/fulfillmentBuild';

export async function scheduleCalculationForMixedOrder(data) {
  let products = [];
  let requestToMatrix = null;
  for (const product of data.products) {
    requestToMatrix = await (async () => {
      try {
        return await scheduleCalculation({ ...data, products: [product] });
      } catch (error) {
        return error;
      }
    })();
    if (requestToMatrix?.message) break;
    products = [...products, ...requestToMatrix.matrix];
  }
  if (requestToMatrix?.message) return formatMatrixError(data, requestToMatrix);
  const newProducts = await consolidationByDeliveryMethod({ products });
  const matrix = await fulfillmentBuild({
    products: newProducts,
    isMixedOrder: true,
  });
  return { matrix };
}

async function consolidationByDeliveryMethod(data) {
  const { products } = data;
  return products.map((p) => {
    const [newTypeOfServicesFormated] = p.typeofServices.map((tosf) =>
      p.isConsolidatedByWarehouse
        ? {
            ...tosf,
          }
        : {
            ...tosf,
            ...maxDateByDeliveryMethod(products),
            bestSchedule: tosf.bestSchedule,
          },
    );
    return {
      ...p,
      typeofServices: [newTypeOfServicesFormated],
    };
  });
}

function maxDateByDeliveryMethod(
  products,
  deliveryMethods = DeliveryMethods.StorePickup,
) {
  const allTypeOfServicesFromProducts = [];

  products.forEach((product) => {
    product.typeofServices.forEach((tos) =>
      allTypeOfServicesFromProducts.push(tos),
    );
  });

  const typeOfServiceStorePickup = allTypeOfServicesFromProducts.find(
    (a) => a.code === DeliveryMethods.StorePickup,
  );
  const uniqTypeOfServices = uniqBy(allTypeOfServicesFromProducts, 'id');

  const maxDate = max(
    uniqTypeOfServices.map(({ dates: [firstDate] }) => firstDate),
  );
  const [firstTypeOfService] = uniqTypeOfServices.filter(
    ({ dates: [firstDate] }) => firstDate.getDate() === maxDate.getDate(),
  );

  return {
    code: deliveryMethods,
    label: deliveryMethods,
    date: firstTypeOfService.date,
    dates: firstTypeOfService.dates,
    pickingDates: firstTypeOfService.pickingDates,
    transferDates: firstTypeOfService.transferDates,
    description: typeOfServiceStorePickup.description,
    receptionDates: firstTypeOfService.receptionDates,
  };
}


// ****** Source: src/domains/schedule/services/index.ts******
import boom from '@hapi/boom';
import { buildData } from './buildData';
import { scheduleCalculation } from './scheduleCalculation';

export async function getSimulatorUnit(body) {
  const { products = [], country, date, commune, channelSales, hour } = body;

  if (products.length === 0) {
    throw boom.badRequest('No se ha encontrado productos');
  }
  if (!date) {
    throw boom.badRequest('Fecha fuera de rango');
  }
  if (!commune) {
    throw boom.badRequest('Comuna o distrito  no encontrado');
  }

  const data = buildData(body, products, country, channelSales, hour, true);

  const requestToMatrix = await (async () => {
    let result = null;
    try {
      result = await scheduleCalculation(data);
    } catch (error) {
      return error;
    }
    return result;
  })();

  if (requestToMatrix?.message) {
    const {
      products: [product],
    } = data;
    return {
      matrix: {
        error: {
          message: requestToMatrix.message,
          data: { sku: product.skuData.sku },
        },
      },
    };
  }

  return requestToMatrix;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/calculateDateRange.ts******
import { addDays, dayBetween } from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function calculateDateRange(data) {
  if (data.dateRange && data.dateRange.id) {
    let firstDay = null;
    let lastDay = null;
    let shippingRateDateRange = null;
    for (let i = 0; i < data.products.length; i++) {
      if (data.products[i].typeofServices) {
        const dateRangeService = getDateRangeTyos(
          data.products[i].typeofServices,
        );
        if (
          dateRangeService &&
          dateRangeService.date &&
          dateRangeService.dates &&
          dateRangeService.dates.length > 0
        ) {
          const {
            dates,
            bestSchedule: {
              frecuency,
              schedule: { capacityByDay, init, end },
              shippingRate,
            },
          } = dateRangeService;
          const [firstDateDispacth] = dates;
          const saleDate = dateRangeService.date;
          firstDay = dayBetween(firstDateDispacth, saleDate);
          lastDay = addDays(firstDateDispacth, 3);
          // eslint-disable-next-line no-await-in-loop
          lastDay = await validDay(
            lastDay,
            [],
            frecuency,
            capacityByDay,
            init,
            end,
          );
          lastDay = dayBetween(lastDay, saleDate);
          data.products[i].dateRange = {
            firstDay: firstDay,
            lastDay: lastDay,
            shippingRate: shippingRate,
            ...data.dateRange,
          };
          shippingRateDateRange = shippingRate;
        }
      }
    }
    data.dateRange.firstDay = firstDay;
    data.dateRange.lastDay = lastDay;
    data.dateRange.shippingRate = shippingRateDateRange;
  }
  return data;
}

function getDateRangeTyos(typeOfservices) {
  let rangeTyos = null;
  for (let i = 0; i < typeOfservices.length; i++) {
    if (typeOfservices[i].code === 'DateRange') {
      rangeTyos = typeOfservices[i];
      typeOfservices.splice(i, 1);
    }
  }
  return rangeTyos;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/courierIsStoreOrWarehouse.ts******
import { getOfficeType } from '../../common/getOfficeType';

export const courierIsStoreOrWarehouse = async (data) => {
  const { products, country } = data;
  if (products[0].typeofServices.length === 0) {
    throw new Error('No hay tipos de servicios para la agenda.');
  }
  const productsPromises = products.map(async (product) => {
    const { typeofServices } = product;
    for (let tosIndex = 0; tosIndex < typeofServices.length; tosIndex++) {
      const {
        bestSchedule: { courier },
      } = typeofServices[tosIndex];
      const { stockSourceType } = (await getOfficeType(courier, country)) || {};
      product.typeofServices[tosIndex].bestSchedule.courierIsStoreOrWarehouse =
        !!stockSourceType;;
    }
    return product;
  });

  return {
    ...data,
    products: await Promise.all(productsPromises),
  };
}

// ****** Source: src/domains/schedule/services/scheduleCalculation/cutTimeByTypeOfService.ts******
import boom from '@hapi/boom';
import {
  addDays,
  dayBetween,
  isOutSideOfCutTime,
} from '../../../../infrastructure/helpers/date';

export async function cutTimeByTypeOfService(data = {}) {
  try {
    const {
      products: [firstProduct],
    } = data as any;
    const { typeofServices } = firstProduct;
    for (let i = 0; i < typeofServices.length; i++) {
      const { date, dates, cutTime } = typeofServices[i];
      let [firstDate] = dates;
      const daysBetween = dayBetween(firstDate, date);
      if (daysBetween === 0 && isOutSideOfCutTime(firstDate, cutTime)) {
        const newDate = addDays(firstDate, 1);
        (data as any).addedDays += 1;
        (data as any).products[0].typeofServices[
          i
        ].joinedDayBycutTimeTypeOfService = true;
        firstDate = newDate;
      }
      typeofServices[i].dates[0] = firstDate;
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/fulfillmentBuild.ts******
import {
  dateDiff,
  getFormatDate,
} from '../../../../infrastructure/helpers/date';
import { DeliveryMethods } from '../../../shipping/entities/constants';

const DATE_FORMAT = 'DD/MM/YYYY';

export async function fulfillmentBuild(data) {
  const { products, isWithCalculationForMixedOrder, isMixedOrder, isPdp } =
    data;
  if (products[0].typeofServices.length === 0) {
    throw new Error('No hay tipos de servicios para la agenda.');
  }

  if (isWithCalculationForMixedOrder) return products;

  if (isMixedOrder) {
    return products.map((product) => ({
      ...product,
      typeofServices: product.typeofServices.map((tos) => {
        tos.fulfillmentDates = getFulfillmentDates(tos);
        return tos;
      }),
    }));
  }

  let commonTypeOfServices: any = getUniqueCommonServiceTypes(products);

  commonTypeOfServices = commonTypeOfServices.map((tos) => {
    tos.fulfillmentDates = isPdp ? [] : getFulfillmentDates(tos);
    return tos;
  });

  return products.map((product) => {
    const {
      request: { deliveryMethod, isLegacyRequest, isRescheduleRequest },
    } = product;

    if (
      isLegacyRequest &&
      !isRescheduleRequest &&
      deliveryMethod === DeliveryMethods.StorePickup
    ) {
      product.typeofServices = [
        ...formatByWarehouse(commonTypeOfServices, product),
      ];
      return product;
    }

    product.typeofServices = [...commonTypeOfServices];
    return product;
  });
}

const getFulfillmentDates = (typeofService) => {
  const {
    bestSchedule: {
      relations = [],
      courierIsStoreOrWarehouse,
      courierCode,
      warehouse: { storeCode },
    },
    pickingDates,
    transferDates,
    receptionDates,
    date,
    dates: dispatchDates,
  } = typeofService;

  if (relations.length === 0)
    throw new Error('La agenda no tiene relaciones directas');

  if (courierIsStoreOrWarehouse && courierCode !== storeCode) {
    const [lastRelation] = [...relations].reverse();
    relations.push(lastRelation);
  }

  return pickingDates.map((currentPickingDate, index) => {
    const sequences = [];
    const numberOfSequences = relations.length - 1;

    for (
      let relationIndex = 0;
      relationIndex < relations.length - 1;
      relationIndex++
    ) {
      const relationFrom = relations[relationIndex];
      const relationTo = relations[relationIndex + 1];
      const sequence = relationIndex + 1;
      const isFirstSequence = relationIndex === 0;
      const isLastSequence = sequence === numberOfSequences;
      const warehouse = getCodeOrNameFromLabel(relationFrom.label);
      const warehouseName = getCodeOrNameFromLabel(relationFrom.label, true);
      const destinationNode = getCodeOrNameFromLabel(relationTo.label);
      const destinationName = getCodeOrNameFromLabel(relationTo.label, true);

      sequences.push({
        sequence,
        warehouse,
        warehouseName,
        destinationNode,
        destinationName,
        planningPickingDate: getPlanningPickingDate(
          isFirstSequence,
          currentPickingDate,
          date,
          sequences,
          numberOfSequences,
        ),
        pickingDate: getPickingDate(isFirstSequence, currentPickingDate),
        transferDate: getTransferDate(
          transferDates,
          index,
          relationFrom,
          isLastSequence,
        ),
        receptionDate: getReceptionDate(
          receptionDates,
          index,
          relationTo,
          isLastSequence,
        ),
        dispatchDay: getDispatchDay(isLastSequence, dispatchDates[index]),
      });
    }

    return sequences;
  });
};

const getCodeOrNameFromLabel = (label = 'ND-', name = false) =>
  label.split('-')[name ? 1 : 0].trim();

const getPlanningPickingDate = (
  isFirstSequence,
  pickingDate,
  saleDate,
  sequences,
  numberOfSequences,
) => {
  if (isFirstSequence) {
    const planningPickingDate =
      dateDiff(pickingDate, saleDate) > 0 ? pickingDate : saleDate;
    return getFormatDate(planningPickingDate, DATE_FORMAT);
  }
  if (numberOfSequences === 1) return '';
  const [lastSequence] = [...sequences].reverse();
  return lastSequence.receptionDate || '';
};

const getUniqueCommonServiceTypes = (products) => {
  // accumulate type of services
  let allTypeOfServices = products.reduce(
    (acc, { typeofServices }) => [...acc, ...typeofServices],
    [],
  );

  // delete duplicate and without pickingDates prop
  allTypeOfServices = Object.values(
    allTypeOfServices.reduce((acc, typeofService) => {
      if (typeofService.pickingDates) {
        const {
          id,
          bestSchedule: {
            courier,
            warehouse: { storeId },
          },
        } = typeofService;
        return { ...acc, [`${id}${courier}${storeId}`]: typeofService };
      }
      return { ...acc };
    }, {}),
  );

  // filter type of services common in all products
  return Object.values(
    allTypeOfServices.reduce((acc, typeOfService) => {
      const match = products.filter((product) =>
        product.typeofServices.some(
          (typeofService) => typeofService.id === typeOfService.id,
        ),
      );
      if (match.length === products.length) {
        const {
          id,
          bestSchedule: {
            courier,
            warehouse: { storeId },
          },
        } = typeOfService;
        return { ...acc, [`${id}${courier}${storeId}`]: typeOfService };
      }
      return { ...acc };
    }, {}),
  );
};

const formatByWarehouse = (typeOfServices, product) =>
  typeOfServices.map((ctos, index) => ({
    ...ctos,
    bestSchedule: {
      ...ctos.bestSchedule,
      warehouse: product.typeofServices[index].bestSchedule.warehouse,
    },
  }));

const getPickingDate = (isFirstSequence, pickingDate) => {
  if (isFirstSequence) {
    return getFormatDate(pickingDate, DATE_FORMAT);
  }
  return '';
};

const getTransferDate = (
  transferDates,
  dateIndex,
  relation,
  isLastSequence,
) => {
  relation.transferDateTrf = relation.transferDateTrf || [];
  if (isLastSequence) return '';
  if (
    transferDates &&
    relation &&
    Object.keys(relation).length > 0 &&
    relation.transferDateTrf &&
    relation.transferDateTrf.length <= 0
  ) {
    return getFormatDate(transferDates[dateIndex], DATE_FORMAT);
  }
  if (relation.transferDateTrf.length > 0) {
    return getFormatDate(relation.transferDateTrf[dateIndex], DATE_FORMAT);
  }
  return '';
};

const getReceptionDate = (
  receptionDates,
  dateIndex,
  relation,
  isLastSequence,
) => {
  relation.receptionExceptDate = relation.receptionExceptDate || [];
  if (isLastSequence) return '';
  if (
    receptionDates &&
    relation &&
    Object.keys(relation).length > 0 &&
    relation.receptionExceptDate &&
    relation.receptionExceptDate.length <= 0
  ) {
    return getFormatDate(receptionDates[dateIndex], DATE_FORMAT);
  }
  if (relation.receptionExceptDate.length > 0) {
    return getFormatDate(relation.receptionExceptDate[dateIndex], DATE_FORMAT);
  }
  return '';
};

const getDispatchDay = (isLastSequence, dispatchDate) => {
  if (isLastSequence) {
    return getFormatDate(dispatchDate, DATE_FORMAT);
  }
  return '';
};


// ****** Source: src/domains/schedule/services/scheduleCalculation/getCapacityData.ts******
import MainRoute from '../../../common/schemas/MainRoute';
import { uniqBy } from 'lodash';
import { getOfficeType } from '../../common/getOfficeType';
import { getObjectIdFromMongoose } from '../../../../infrastructure/helpers/mongoHelper';

export async function getCapacityData(data) {
  const { products, country } = data;
  let allTypeOfServices = [];
  products.forEach((product) => {
    allTypeOfServices = [
      ...allTypeOfServices,
      ...product.typeofServices.map((tos) => tos),
    ];
  });

  allTypeOfServices = uniqBy(allTypeOfServices, 'bestSchedule._id');

  const requests = allTypeOfServices.map((tos) => {
    const {
      bestSchedule: { _id },
    } = tos;
    return MainRoute.aggregate()
      .match({ _id: getObjectIdFromMongoose(_id) })
      .addFields({
        'schedule.capacityByDay': { $objectToArray: '$schedule.capacityByDay' },
      })
      .project({
        _id: 1,
        'schedule.capacityByDay': 1,
      })
      .exec();
  });

  const capacities = await Promise.all(requests);
  const results = capacities.reduce(
    (acc, [result]) => (result ? [...acc, result] : acc),
    [],
  );

  const productsPromises = products.map(async (product) => {
    const { typeofServices } = product;
    for (let tosIndex = 0; tosIndex < typeofServices.length; tosIndex++) {
      if (results && results.length === 0) {
        throw new Error(
          `No se encontró capacidades para la agenda con tipo de servicio ${typeofServices[tosIndex].code}`,
        );
      }
      const {
        bestSchedule: { _id, courier },
      } = typeofServices[tosIndex];
      const { schedule } = results.find(
        (cap) => String(cap._id) === String(_id),
      );
      product.typeofServices[tosIndex].bestSchedule.schedule.capacityByDay =
        parseCapacityArrayToObject(schedule.capacityByDay);
      const { stockSourceType } = (await getOfficeType(courier, country)) || {};
      product.typeofServices[tosIndex].bestSchedule.courierIsStoreOrWarehouse =
        !!stockSourceType;
    }
    return product;
  });

  return {
    ...data,
    products: await Promise.all(productsPromises),
  };
}

function parseCapacityArrayToObject(capacity) {
  const capacityByDay = {};
  capacity.forEach((item) => {
    capacityByDay[item.k] = item.v;
  });
  return capacityByDay;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/getHolidays.ts******
import boom from '@hapi/boom';
import { getCacheClient } from '../../../../infrastructure/gateways/cacheClient';
import Holiday from '../../../common/schemas/Holiday';
import {
  evaluateDatesArray,
  makeDate,
} from '../../../../infrastructure/helpers/date';
import { getOfficeType } from '../../common/getOfficeType';
import { validDay } from '../../common/validDay';

export async function getHolidays(data) {
  try {
    const {
      products: [product],
      app: { country },
      date,
    } = data;
    product.typeofServices =
      product.typeofServices || product.typeOfServicesFormated;
    if (!product.typeofServices.length)
      throw boom.badRequest('No se ha encontrado tipos de servicios');
    const { typeofServices } = product;
    const redisKey = `${country}-Holidays`;
    const redisKeyVendor = `${country}-Holidays-StoreCode:vendor`;
    const dateRequest = date || getDateRequest(product);
    const filter = { country, dateRequest, storeCode: '' };
    const filterVendor = { country, storeCode: 'vendor' };
    const countryHolidaysRipley = await getCacheClient().wrapperQuery(
      redisKey,
      async () => Holiday.findHoliday(filter),
    );

    let countryHolidays;

    for (const typeOfService of typeofServices) {
      typeOfService.holidays = typeOfService.holidays || {};
      const {
        bestSchedule: { relations },
        holidays,
      } = typeOfService;
      let { dates } = typeOfService;

      for (const relation of relations) {
        const { stockSourceType, type } = await getOfficeType(
          relation.id,
          country,
        );
        const isVendor =
          stockSourceType === 'vendor' &&
          type &&
          (type.isSupplierDdc || type.isSupplierDvo || type.isSupplierDvr);
        if (isVendor) {
          const countryHolidaysVendor = await getCacheClient().wrapperQuery(
            redisKeyVendor,
            async () => Holiday.findHolidayVendor(filterVendor),
          );
          countryHolidays = [...countryHolidaysVendor];
        } else {
          countryHolidays = [...countryHolidaysRipley];
        }
        const relationHolidays = await defineHolidaysByRelation(
          relation,
          holidays,
          countryHolidays,
          redisKey,
          filter,
          isVendor,
        );
        dates = await evaluateDatesArray(dates, 0, relationHolidays, validDay);
        typeOfService.holidays = relationHolidays;
      }
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

function getDateRequest({ typeofServices: [{ date }] }) {
  return date || makeDate(null);
}

async function defineHolidaysByRelation(
  relation,
  holidays,
  countryHolidays,
  redisKey,
  filter,
  isVendor = false,
) {
  const storeCode = relation.code;
  const relationRedisKey = `${redisKey}-StoreCode:${storeCode}`;
  if (holidays[storeCode] && holidays[storeCode].length > 0) {
    relation.holidays = { [storeCode]: [...holidays[storeCode]] };
    return relation.holidays;
  }
  if (!holidays[storeCode]) {
    let relationHolidays = [];
    const nameForHolidayQuery = isVendor ? 'findHolidayVendor' : 'findHoliday';
    relationHolidays = await getCacheClient().wrapperQuery(
      relationRedisKey,
      async () => Holiday[nameForHolidayQuery]({ ...filter, storeCode }),
    );
    holidays[storeCode] =
      relationHolidays.length || isVendor ? relationHolidays : countryHolidays;
  }
  if (isVendor) {
    const countryHolidaysFiltered = countryHolidays.filter(
      (countryHolidayDate) =>
        !holidays[storeCode].some(
          (dt) => dt.date === countryHolidayDate && !dt.status,
        ),
    );
    const flatDates = holidays[storeCode]
      .filter((dt) => dt.status)
      .map((d) => d.date);
    const newHolidays = flatDates.concat(countryHolidaysFiltered);
    relation.holidays = {
      ...holidays,
      ...relation.holidays,
      [storeCode]: newHolidays,
    };
    holidays[storeCode] = newHolidays;
    return relation.holidays;
  }
  const newHolidays = holidays[storeCode].concat(countryHolidays);
  relation.holidays = {
    ...holidays,
    ...relation.holidays,
    [storeCode]: newHolidays,
  };

  return relation.holidays;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/index.ts******
import { cloneDeep } from 'lodash';
import { executeFlow } from '../../common/executeFlow';
import { getCapacityData } from './getCapacityData';
import { getHolidays } from './getHolidays';
import { cutTimeByTypeOfService } from './cutTimeByTypeOfService';
import { manufactureLeadTime } from './manufactureLeadTime';
import { pickingSchedule } from './pickingSchedule';
import { internalWork } from './internalWork';
import { scheduleTransfer } from './scheduleTransfer';
import { scheduleDaysTRF } from './scheduleDaysTRF';
import { transferRelation } from './transferRelation';
import { scheduleReception } from './scheduleReception';
import { scheduleReceptionExceptDays } from './scheduleReceptionExceptDays';
import { indirectFlow } from './indirectFlow';
import { slackOfHierarchy } from './slackOfHierarchy';
import { slackByTypeOfService } from './slackByTypeOfService';
import { termLastMile } from './termLastMile';
import { routeFrequency } from './routeFrequency';
import { scheduleOfDispatch } from './scheduleOfDispatch';
import { calculateDateRange } from './calculateDateRange';
import { courierIsStoreOrWarehouse } from './courierIsStoreOrWarehouse';
import { fulfillmentBuild } from './fulfillmentBuild';
import { logFlow } from '../../common/logFlow';
import { formatFulfillment } from '../../../fulfillment/services/fulfillmentCalculation/formatFulfillment';

export async function scheduleCalculation(data) {
  const originalData = cloneDeep(data);
  data.products.forEach((product) => {
    product.request.scheduleCalculationData = { ...originalData };
  });
  try {
    const matrix = await executeFlow(
      data,
      getCapacityData,
      getHolidays,
      /* *** sucursal de stock/warehouse *** */
      cutTimeByTypeOfService,
      logFlow('warehouse', 'Horario de corte', true),
      manufactureLeadTime,
      logFlow('warehouse', 'Plazo de fabricación', true),
      pickingSchedule,
      logFlow('warehouse', 'Agenda de Picking', true),
      internalWork,
      logFlow('warehouse', 'Trabajo interno', true),
      logFlow('warehouse', 'Fecha excepción TRF'),
      scheduleTransfer,
      logFlow('warehouse', 'Agenda de transferencia', true),
      scheduleDaysTRF,
      logFlow('warehouse', 'Día semana TRF', true),
      transferRelation,
      logFlow('warehouse', 'Plazo transferencia', true),
      /* *** operador logístico/courier *** */
      scheduleReception,
      logFlow('courier', 'Agenda de recepción', true),
      scheduleReceptionExceptDays,
      logFlow('courier', 'Fecha excepción recepción', true),
      indirectFlow,
      slackOfHierarchy,
      logFlow('courier', 'Holgura por Jerarquía', true),
      slackByTypeOfService,
      logFlow('courier', 'Holgura por tipo de servicio', true),
      termLastMile,
      logFlow('courier', 'Plazo Última Milla', true),
      routeFrequency,
      logFlow('courier', 'Frecuencia Ruta', true),
      scheduleOfDispatch,
      logFlow('courier', 'Agenda de despacho', true),
      calculateDateRange,
      // sameDateValidation,
      fulfillmentBuild,
    );
    return { matrix, data };
  } catch (error) {
    if (data.isWithLog) return { message: error.message };
    return { matrix: { message: error.message } };
  }
}

export async function scheduleCalculationFulfillment(data) {
  try {
    const matrix = await executeFlow(
      data,
      getHolidays,
      /* *** sucursal de stock/warehouse *** */
      manufactureLeadTime,
      pickingSchedule,
      internalWork,
      scheduleTransfer,
      scheduleDaysTRF,
      transferRelation,
      /* *** operador logístico/courier *** */
      scheduleReception,
      scheduleReceptionExceptDays,
      indirectFlow,
      slackOfHierarchy,
      slackByTypeOfService,
      termLastMile,
      routeFrequency,
      courierIsStoreOrWarehouse,
      fulfillmentBuild,
      formatFulfillment,
    );
    return { matrix };
  } catch (error) {
    return { message: error.message };
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/indirectFlow.ts******
import boom from '@hapi/boom';
import {
  receptionTypeOfServices,
  scheduleTypeOfServices,
} from '../../common/typeOfServicesFunctions';
import { getOfficeType } from '../../common/getOfficeType';
import {
  addDays,
  dayBetween,
  evaluateDatesArray,
} from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function indirectFlow(data) {
  try {
    const {
      products: [firstProduct],
      country,
      orderData,
    } = data;
    const { typeofServices, schedulesToConsume } = firstProduct;
    for (const service of typeofServices) {
      const [dateBefore] = [...service.dates];
      const { bestSchedule } = service;
      const { relations } = bestSchedule;
      if (relations.length > 2) {
        await indirectRelations(
          data,
          service,
          orderData,
          relations,
          country,
          schedulesToConsume,
        );
        await reFlowIndirect(data, relations);
      }
      const [dateAfter] = [...service.dates];
      data.addedDays += dayBetween(dateBefore, dateAfter);
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function indirectRelations(
  data,
  service,
  orderData,
  relations,
  country,
  schedulesToConsume,
) {
  for (let i = 0; i < relations.length; i++) {
    const v = i + 1;
    const warehouseObj = await getOfficeType(relations[i].id, country);
    const warehouseCode = warehouseObj.storeCode;
    const warehouse: any = {
      storeCode: warehouseCode,
      storeId: relations[i].id,
    };
    if (i === 0) {
      const courierObj = await getOfficeType(relations[v].id, country);
      if (
        courierObj.type.isStoreOffice &&
        relations[i].id !== relations[v].id
      ) {
        const { storeCode } = courierObj;
        const { courier } = relations[i];
        await scheduleTypeOfServices(
          service,
          country,
          relations,
          orderData,
          false,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
        await scheduleTypeOfServices(
          service,
          country,
          relations,
          orderData,
          true,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
        await transferRelationIndirect(data, relations[v]);
      }
    }

    if (i === relations.length - 1) {
      const courierObj = await getOfficeType(relations[i].id, country);
      const { storeCode } = courierObj;
      const { courier } = relations[i];
      if (warehouseObj.type.isStoreOffice) {
        await receptionTypeOfServices(
          service,
          country,
          null,
          orderData,
          false,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
        await receptionTypeOfServices(
          service,
          country,
          null,
          orderData,
          true,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
      }
    }

    if (i < relations.length - 1 && i > 0) {
      const courierObj = await getOfficeType(relations[v].id, country);
      const { storeCode } = courierObj;
      const { courier } = relations[i];
      if (warehouseObj.type.isStoreOffice) {
        await receptionTypeOfServices(
          service,
          country,
          null,
          orderData,
          false,
          true,
          warehouse,
          warehouse.storeId,
          warehouse.storeCode,
          relations[i],
          schedulesToConsume,
        );
        await receptionTypeOfServices(
          service,
          country,
          null,
          orderData,
          true,
          true,
          warehouse,
          warehouse.storeId,
          warehouse.storeCode,
          relations[i],
          schedulesToConsume,
        );
      }
      if (
        courierObj.type.isStoreOffice &&
        relations[i].id !== relations[v].id
      ) {
        await scheduleTypeOfServices(
          service,
          country,
          relations,
          orderData,
          false,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
        await scheduleTypeOfServices(
          service,
          country,
          relations,
          orderData,
          true,
          true,
          warehouse,
          courier,
          storeCode,
          relations[i],
          schedulesToConsume,
        );
        await transferRelationIndirect(data, relations[v]);
      }
    }
  }
}

async function transferRelationIndirect(data, relation) {
  try {
    const {
      products: [firstProduct],
      country,
    } = data;
    const { typeofServices } = firstProduct;
    for (const typeofService of typeofServices) {
      const { bestSchedule, dates } = typeofService;
      if (relation.transferPeriod >= 0) {
        const [newDates, courier] = await Promise.all([
          evaluateDatesArray(
            dates,
            relation.transferPeriod,
            relation.holidays,
            validDay,
          ),
          getOfficeType(bestSchedule.courier, country),
        ]);
        if (courier.stockSourceType) {
          typeofService.transferPeriod = dayBetween(
            new Date(dates[0]),
            new Date(newDates[0]),
          );
          data.addedDays += typeofService.transferPeriod;
        }
        typeofService.dates = newDates;
        relation.scheduleTransferDays = dates.map(
          () => relation.transferPeriod,
        );
      }
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function reFlowIndirect(data, relations) {
  const {
    products: [firstProduct],
  } = data;
  const { typeofServices } = firstProduct;
  for (let i1 = 0; i1 < typeofServices.length; i1++) {
    const {
      log = {},
      transferPreviousDates,
      dates,
      holidays,
    } = typeofServices[i1];

    for (
      let dateIndex = 0;
      dateIndex < transferPreviousDates.length;
      dateIndex++
    ) {
      const currentDate = transferPreviousDates[dateIndex];
      const daysTransfer = sumRelationByProperty(
        relations,
        'transferScheduleDateDays',
        dateIndex,
      );
      const daysTransferExcept = sumRelationByProperty(
        relations,
        'transferDateTrfDays',
        dateIndex,
      );
      const daysReception = sumRelationByProperty(
        relations,
        'receptionScheduleDateDays',
        dateIndex,
      );
      const daysReceptionExcept = sumRelationByProperty(
        relations,
        'receptionExceptDateDays',
        dateIndex,
      );
      const daysScheduleTransfer = sumRelationByProperty(
        relations,
        'scheduleTransferDays',
        dateIndex,
      );

      let transferDate = new Date(addDays(currentDate, daysTransfer));
      transferDate = await validDay(transferDate, holidays);

      const transferDateExcept = new Date(
        addDays(transferDate, daysTransferExcept),
      );
      let scheduletransferDate = new Date(
        addDays(transferDateExcept, daysScheduleTransfer),
      );
      scheduletransferDate = await validDay(scheduletransferDate, holidays);
      const receptionDate = new Date(
        addDays(scheduletransferDate, daysReception),
      );
      const receptionDateExcept = new Date(
        addDays(receptionDate, daysReceptionExcept),
      );
      dates[dateIndex] = receptionDateExcept;

      const currentLog = log[dateIndex];

      if (currentLog) {
        const scheduleTransferLog = currentLog.find(
          (value) => value.functionName === 'Agenda de transferencia',
        );
        scheduleTransferLog.date = transferDate.getTime();

        const scheduleTransferExceptDaysLog = currentLog.find(
          (value) => value.functionName === 'Día semana TRF',
        );
        scheduleTransferExceptDaysLog.date = transferDateExcept.getTime();

        const scheduleTransferDateLog = currentLog.find(
          (value) => value.functionName === 'Plazo transferencia',
        );
        scheduleTransferDateLog.date = scheduletransferDate.getTime();

        const scheduleReceptionLog = currentLog.find(
          (value) => value.functionName === 'Agenda de recepción',
        );
        scheduleReceptionLog.date = receptionDate.getTime();

        const scheduleReceptionExceptDaysLog = currentLog.find(
          (value) => value.functionName === 'Fecha excepción recepción',
        );
        scheduleReceptionExceptDaysLog.date = receptionDateExcept.getTime();
      }
      data.products[0].typeofServices[i1].transferDates = [transferDateExcept];
      data.products[0].typeofServices[i1].receptionDates = [
        receptionDateExcept,
      ];
    }
    data.products[0].typeofServices[i1].dates = dates;
  }

  return data;
}

function sumRelationByProperty(relations, propertyName, index) {
  return relations.reduce((sum, relation) => {
    if (relation[propertyName]) {
      const increment = relation[propertyName][index] || 0;
      return sum + increment;
    }
    return sum;
  }, 0);
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/internalWork.ts******
import boom from '@hapi/boom';
import { uniq } from 'lodash';
import { getCacheClient } from '../../../../infrastructure/gateways/cacheClient';
import Office from '../../../common/schemas/Office';
import { validDay } from '../../common/validDay';
import {
  dayBetween,
  evaluateDatesArray,
} from '../../../../infrastructure/helpers/date';

export async function internalWork(data = {} as any) {
  try {
    const {
      products: [firstProduct],
    } = data;
    const warehouseCodes = firstProduct.typeofServices.map(
      (typeofService) => typeofService.bestSchedule.warehouse.storeCode,
    );
    const warehouseCodesArray = uniq([].concat(...warehouseCodes));
    // get internalWorkDays from warehouses offices
    const warehousesInternalWorkDays = await getCacheClient().wrapperQuery(
      `Office${warehouseCodesArray.join('-')}`,
      async () =>
        Office.find(
          { storeCode: { $in: warehouseCodesArray } },
          { _id: 1, internalWorkDays: 1, storeCode: 1 },
          { lean: true },
        ),
    );

    const { typeofServices } = firstProduct;
    for (const typeofService of typeofServices) {
      const {
        dates,
        holidays = {},
        bestSchedule: {
          warehouse: { storeCode },
        },
      } = typeofService;
      // find by store code
      const workDays = warehousesInternalWorkDays.find(
        (warehouseRule) => warehouseRule.storeCode === storeCode,
      ).internalWorkDays;
      const [firstDate] = dates;
      typeofService.dates = await evaluateDatesArray(
        dates,
        workDays,
        holidays[storeCode],
        validDay,
      );
      data.addedDays +=
        workDays + dayBetween(firstDate, typeofService.dates[0]);
      typeofService.transferPreviousDates = [...typeofService.dates];
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/manufactureLeadTime.ts******
import boom from '@hapi/boom';
import ManufactureModel from '../../../common/schemas/Manufacture';
import { getCacheClient } from '../../../../infrastructure/gateways/cacheClient';
import { validDay } from '../../common/validDay';
import {
  evaluateDatesArray,
  isBetween,
} from '../../../../infrastructure/helpers/date';
import moment from 'moment';
import { getObjectIdFromMongoose } from '../../../../infrastructure/helpers/mongoHelper';

export async function manufactureLeadTime(data) {
  try {
    const { products, country, date, hour } = data;
    const [firstProduct] = products;
    let manufactureDays = {};

    for (const product of products) {
      const { typeofServices } = product;
      for (const typeofService of typeofServices) {
        const { bestSchedule, code } = typeofService;

        const { shortCode } = product.skuData;
        const manufactureDataArray =
          product.skuData.hierarchies &&
          (await getManufactureRelation(
            country,
            String(shortCode),
            product.skuData.hierarchies[1],
            product.skuData.hierarchies[2],
            product.skuData.hierarchies[3],
            bestSchedule.warehouse.storeId,
          ));
        if (
          product.skuData.hierarchies.length > 0 &&
          manufactureDataArray.length > 0
        ) {
          const manufactureData = await selectManufactureData(
            manufactureDataArray,
            String(shortCode),
            product.skuData.hierarchies[2],
            product.skuData.hierarchies[1],
            product.skuData.hierarchies[3],
          );
          if (manufactureData) {
            const daysToAdd = await getDaysFromManufactureData(
              date,
              hour,
              manufactureData,
            );
            manufactureDays = {
              ...manufactureDays,
              [code]:
                daysToAdd > (manufactureDays[code] || 0)
                  ? daysToAdd
                  : manufactureDays[code] || 0,
            };
          }
        }
      }
    }

    for (const typeService of firstProduct.typeofServices) {
      const {
        dates,
        holidays = {},
        code,
        bestSchedule: {
          warehouse: { storeCode },
        },
      } = typeService;
      const days = manufactureDays[code] || 0;
      typeService.dates = await evaluateDatesArray(
        dates,
        days,
        holidays[storeCode],
        validDay,
        [],
        true,
      );
    }

    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function getManufactureRelation(
  country,
  sku,
  subline,
  line,
  department,
  warehouseId,
) {
  try {
    const result = await getCacheClient().wrapperQuery(
      `${country}-Manufacture-${warehouseId}`,
      async () =>
        // TODO: Revisar optimización de query
        ManufactureModel.where(
          {
            warehouse: getObjectIdFromMongoose(warehouseId),
          } as any,
          {
            rules: 1,
            sku: 1,
            subline: 1,
            line: 1,
            department: 1,
          },
        )
          .lean()
          .exec(),
    );
    return result.filter(
      (doc) =>
        doc.sku === sku ||
        doc.subline === subline ||
        doc.line === line ||
        doc.department === department,
    );
  } catch (err) {
    throw boom.boomify(err);
  }
}

function selectManufactureData(
  manufactureDataArray,
  sku,
  line,
  subline,
  department,
) {
  if (sku) {
    const skuToString = sku.toString();
    const objectSku = manufactureDataArray.find(
      (item) => item.sku === skuToString,
    );
    if (validatManufacture(objectSku)) {
      return objectSku;
    }
  }
  if (subline) {
    const sublineToString = subline.toString();
    const objectSubline = manufactureDataArray.find(
      (item) => item.subline === sublineToString,
    );
    if (validatManufacture(objectSubline)) {
      return objectSubline;
    }
  }
  if (line) {
    const lineToString = line.toString();
    const objectLine = manufactureDataArray.find(
      (item) => item.line === lineToString,
    );
    if (validatManufacture(objectLine)) {
      return objectLine;
    }
  }

  if (department) {
    const departmentToString = department.toString();
    const objectDepartment = manufactureDataArray.find(
      (item) => item.department === departmentToString,
    );
    if (validatManufacture(objectDepartment)) {
      return objectDepartment;
    }
  }
  return null;
}

function validatManufacture(manufactureObject) {
  if (
    manufactureObject &&
    (manufactureObject.rules.exceptDays > 0 || manufactureObject.rules.days > 0)
  ) {
    return manufactureObject;
  }
  return false;
}

function getDaysFromManufactureData(today, hour, manufactureData = {} as any) {
  if (
    manufactureData.rules?.initExceptDate &&
    manufactureData.rules?.endExceptDate &&
    manufactureData.rules?.exceptDays >= 0
  ) {
    const { rules } = manufactureData;
    const { initExceptDate, endExceptDate } = rules;
    const time = moment.duration(hour);
    const day = moment(`${today}`, 'DD/MM/YYYY').add(time);
    const now = day.toDate();
    const iDate = moment(initExceptDate, 'YYYY-MM-DD').toDate();
    const eDate = moment(endExceptDate, 'YYYY-MM-DD').toDate();
    const dateValidation = isBetween(now, iDate, eDate);
    if (dateValidation) {
      return manufactureData.rules.exceptDays;
    }
    return manufactureData.rules.days;
  }
  return manufactureData.rules.days;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/pickingSchedule.ts******
import boom from '@hapi/boom';
import Office from '../../../common/schemas/Office';
import Schedule from '../../../common/schemas/Schedule';
import moment from 'moment';
import Capacity from '../../../common/schemas/Capacity';
import { validDay } from '../../common/validDay';
import {
  addDays,
  checkDateRange,
  getDayNameFromDate,
  isOutOfCutTime,
  isSameOrAfter,
} from '../../../../infrastructure/helpers/date';
import { hasCapacityGenericForSchedules } from '../../common/hasCapacityGenericForSchedules';
import {
  filterTypesOfServicesWithPicking,
  isValidCapacity,
} from '../../../../infrastructure/helpers/schedule';
import { modifyDataSchedules } from '../../common/modifyDataSchedules';
import { ScheduleErrors } from '../../../shipping/entities/constants';
import { getObjectIdFromMongoose } from '../../../../infrastructure/helpers/mongoHelper';

export async function pickingSchedule(data = {} as any) {
  try {
    const { products, orderData, isWithCalculationForMixedOrder } = data;
    let existPickingAvailable = false;
    let existsPickingSchedule = false;
    const codeStore = [];
    for (const indexProduct of products) {
      const { typeofServices } = indexProduct;
      const pickingSchedules = [];

      for (const service of typeofServices) {
        const {
          id,
          date,
          dates,
          holidays = {},
          bestSchedule: {
            warehouse: { storeId, storeCode, storeType },
            courier,
          },
        } = service;
        // TODO: revisar cambio de tipo de dato de string a objeto
        let calculation = '' as any;
        let setOfData = '' as any;

        if (storeType === 'vendor') {
          setOfData = {
            storeId,
            id,
            holidays: holidays[storeCode],
            storeCode,
            courier,
          };
          calculation = await supplierPickingCalculation(
            setOfData,
            dates,
            orderData,
            date,
            data,
            service,
            pickingSchedules,
          );
          indexProduct.schedulesToConsume.pickingSupplierSchedule =
            pickingSchedules;
          service.flowTypeVendor = calculation.flowType;
        } else {
          setOfData = {
            storeId,
            id,
            holidays: holidays[storeCode],
            storeCode,
          };
          calculation = await pickingScheduleCalculation(
            setOfData,
            dates,
            orderData,
            date,
            data,
            service,
            pickingSchedules,
          );
          indexProduct.schedulesToConsume.pickingSchedule = pickingSchedules;
        }
        service.existsPickingSchedule = calculation.existsPickingSchedule;
        service.existPickingAvailable = calculation.existPickingAvailable;
        if (calculation.existsPickingSchedule) {
          existsPickingSchedule = true;
        }
        if (calculation.existPickingAvailable) {
          existPickingAvailable = true;
        }
        if (!existsPickingSchedule || !existPickingAvailable) {
          codeStore.push({ warehouse: storeCode });
        }
        service.pickingDates = [...dates];
      }
      if (!isWithCalculationForMixedOrder) break;
    }

    if (!existsPickingSchedule)
      throw new Error(
        `No existe agenda de picking ${JSON.stringify(codeStore)}`,
      );
    if (!existPickingAvailable)
      throw new Error(
        `No existe disponibilidad en agenda de picking ${JSON.stringify(
          codeStore,
        )}`,
      );

    return filterTypesOfServicesWithPicking(
      data,
      isWithCalculationForMixedOrder,
    );
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function pickingScheduleCalculation(
  setOfData,
  datesArray,
  orderDataArray,
  dateElement,
  dataObject,
  typeOfServices,
  pickingSchedulesArray,
) {
  let existPickingAvailable = false;
  let existsPickingSchedule = false;
  const pickSchedule: any = await Schedule.findOne(
    {
      warehouses: getObjectIdFromMongoose(setOfData.storeId),
      services: getObjectIdFromMongoose(setOfData.id),
      'type.isPickingSchedule': true,
      active: true,
    }, // check active flag
    {
      _id: 1,
      active: 1,
      services: 1,
      warehouses: 1,
      capacities: 1,
      weekCutTime: 1,
      unitMeasure: 1,
      validityEnd: 1,
      validityStart: 1,
      weekBaseCapacity: 1,
    },
    {},
  )
    .lean()
    .exec();

  const initialDates = [...datesArray];

  if (pickSchedule) {
    existsPickingSchedule = true;
    const { capacityId } = pickSchedule.capacities.find(
      ({ warehouseId }) => warehouseId.toString() === setOfData.storeId,
    );
    const pickingCapacity = await Capacity.findOne(
      { _id: capacityId },
      { _id: 1, capacityByDayArray: 1 },
      {},
    )
      .lean()
      .exec();

    if (pickingCapacity) {
      for (let dateIndex = 0; dateIndex < datesArray.length; dateIndex++) {
        let cutoffScheduleApplied = false;
        let newDate = await validDay(datesArray[dateIndex], setOfData.holidays);
        const containeDateRange = checkDateRange(
          pickSchedule.validityStart,
          pickSchedule.validityEnd,
          newDate,
        );
        if (!containeDateRange)
          throw new Error(
            `Agenda de picking ${setOfData.storeCode}: ${ScheduleErrors.NoDateRange}`,
          );
        for (const capacity of pickingCapacity.capacityByDayArray) {
          newDate = await validDay(newDate, setOfData.holidays);
          // if consulted day is same or after
          if (isSameOrAfter(capacity.day, newDate, 'day')) {
            // If has capacity
            const hasCapacity = hasCapacityGenericForSchedules(capacity, {
              ...orderDataArray,
              unitMeasure: pickSchedule.unitMeasure,
            });
            if (!cutoffScheduleApplied) {
              const weekCutTime =
                pickSchedule.weekCutTime[getDayNameFromDate(capacity.day)];
              if (isOutOfCutTime(dateElement, weekCutTime)) {
                newDate = addDays(newDate, 1);
                cutoffScheduleApplied = true;
                // eslint-disable-next-line no-continue
                continue;
              }
            }
            if (isValidCapacity(capacity) && hasCapacity) {
              existPickingAvailable = true;
              datesArray[dateIndex] = newDate;
              break;
            } else {
              newDate = addDays(newDate, 1);
            }
          }
        }
      }
      modifyDataSchedules(
        dataObject,
        typeOfServices,
        pickingSchedulesArray,
        {
          typeOfServices: [setOfData.id],
          warehouseId: setOfData.storeId,
          warehouseCode: setOfData.storeCode,
          capacityId: pickingCapacity._id.toString(),
          unitMeasure: pickSchedule.unitMeasure,
        },
        datesArray,
        initialDates,
      );
    }
  }
  return { existPickingAvailable, existsPickingSchedule };
}

async function supplierPickingCalculation(
  setOfData,
  dates,
  orderData,
  date,
  data,
  typeofServices,
  pickingSchedules,
) {
  let existPickingAvailable = false;
  let existsPickingSchedule = false;
  const [dateToEval] = dates;
  const opl = await Office.findOne(
    {
      _id: getObjectIdFromMongoose(setOfData.courier),
    },
    {
      type: 1,
    },
    {},
  )
    .lean()
    .exec();
  const flowType = flowTypeSelector(opl.type);
  const selectedPickSchedule = await Schedule.findOne(
    {
      warehouses: getObjectIdFromMongoose(setOfData.storeId),
      services: getObjectIdFromMongoose(setOfData.id),
      active: true,
      validityStart: { $lte: moment(dateToEval).startOf('day').utc() },
      validityEnd: { $gte: moment(dateToEval).startOf('day').utc() },
      'type.isPickingSupplierSchedule': true,
      'subSchedulesSupplier.name': flowType,
    },
    {
      capacities: 1,
      unitMeasure: 1,
      subSchedulesSupplier: 1,
    },
    { sort: { createdAt: -1 } },
  )
    .lean()
    .exec();

  const initialDates = [...dates];

  if (selectedPickSchedule) {
    existsPickingSchedule = true;
    const subSchedule: any = selectedPickSchedule.subSchedulesSupplier.find(
      (element) => (element as any).name === flowType,
    );

    const subScheduleCapacity: any = selectedPickSchedule.capacities.find(
      (element) =>
        String((element as any).subScheduleId) === String(subSchedule._id),
    );

    const subGeneralScheduleCapacity: any =
      selectedPickSchedule.capacities.find(
        (element) => !(element as any).subScheduleId,
      );

    const pickingCapacity = await Capacity.findOne(
      { _id: subScheduleCapacity.capacityId },
      { _id: 1, capacityByDayArray: 1 },
      {},
    )
      .lean()
      .exec();

    const generalPickingCapacity = await Capacity.findOne(
      { _id: subGeneralScheduleCapacity.capacityId },
      { _id: 1, capacityByDayArray: 1 },
      {},
    )
      .lean()
      .exec();

    if (pickingCapacity) {
      for (let dateIndex = 0; dateIndex < dates.length; dateIndex++) {
        let cutoffScheduleApplied = false;
        let newDate = await validDay(dates[dateIndex], setOfData.holidays);
        for (
          let index = 0;
          index < pickingCapacity.capacityByDayArray.length;
          index++
        ) {
          const capacity = pickingCapacity.capacityByDayArray[index];
          const generalCapacity =
            generalPickingCapacity.capacityByDayArray[index];

          newDate = await validDay(newDate, setOfData.holidays);
          // if consulted day is same or after
          if (isSameOrAfter(capacity.day, newDate, 'day')) {
            // If has capacity
            const hasCapacity = hasCapacityGenericForSchedules(capacity, {
              ...orderData,
              unitMeasure: selectedPickSchedule.unitMeasure,
            });
            const hasCapacityGeneral = hasCapacityGenericForSchedules(
              generalCapacity,
              { ...orderData, unitMeasure: selectedPickSchedule.unitMeasure },
            );
            if (!cutoffScheduleApplied) {
              const weekCutTime =
                subSchedule.weekCutTime[getDayNameFromDate(capacity.day)];
              if (isOutOfCutTime(date, weekCutTime)) {
                newDate = addDays(newDate, 1);
                cutoffScheduleApplied = true;
                // eslint-disable-next-line no-continue
                continue;
              }
            }
            if (
              isValidCapacity(capacity) &&
              hasCapacity &&
              isValidCapacity(generalCapacity) &&
              hasCapacityGeneral
            ) {
              existPickingAvailable = true;
              dates[dateIndex] = newDate;
              break;
            } else {
              newDate = addDays(newDate, 1);
            }
          }
        }
      }

      modifyDataSchedules(
        data,
        typeofServices,
        pickingSchedules,
        {
          typeOfServices: [setOfData.id],
          warehouseId: setOfData.storeId,
          warehouseCode: setOfData.storeCode,
          capacityId: pickingCapacity._id,
          unitMeasure: selectedPickSchedule.unitMeasure,
          mainCapacityId: generalPickingCapacity._id,
        },
        dates,
        initialDates,
      );
    }
  }
  return { existPickingAvailable, existsPickingSchedule, flowType };
}

const flowTypeSelector = (types) => {
  if (types.isSupplierDdc) {
    return 'DDC';
  }
  if (types.isSupplierDvo) {
    return 'DVO';
  }
  if (types.isSupplierDvr) {
    return 'DVR';
  }
  return false;
};


// ****** Source: src/domains/schedule/services/scheduleCalculation/routeFrequency.ts******
import boom from '@hapi/boom';
import LogHandler from '../../../../infrastructure/common/handlers/logHandler';
import {
  dayBetween,
  evaluateDatesArray,
} from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function routeFrequency(data = {} as any) {
  try {
    const {
      products: [firstProduct],
    } = data;
    const typeofServices = validateRouteFrequency(firstProduct);
    for (let i = 0; i < typeofServices.length; i++) {
      const {
        dates,
        holidays = {},
        bestSchedule: { frecuency, courierCode },
      } = typeofServices[i];
      const [firstDate] = dates;
      typeofServices[i].dates = await evaluateDatesArray(
        dates,
        0,
        holidays[courierCode],
        validDay,
        frecuency,
      );
      data.addedDays += dayBetween(firstDate, typeofServices[i].dates[0]);
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

const validateRouteFrequency = (product) => {
  const typeofServices = product.typeofServices.filter(({ bestSchedule }) => {
    const { frecuency, courierCode } = bestSchedule;
    if (frecuency.length === 0) {
      LogHandler.info(
        `No hay frecuencia configurada para la oficina: ${courierCode}`,
      );
      return false;
    }
    return true;
  });
  product.typeofServices = typeofServices;
  return typeofServices;
};


// ****** Source: src/domains/schedule/services/scheduleCalculation/scheduleDaysTRF.ts******
import boom from '@hapi/boom';
import { dayBetween } from '../../../../infrastructure/helpers/date';
import { scheduleTypeOfServices } from '../../common/typeOfServicesFunctions';

export async function scheduleDaysTRF(data) {
  try {
    const {
      products: [firstProduct],
      country,
      orderData,
    } = data;
    const { typeofServices, schedulesToConsume } = firstProduct;
    for (const service of typeofServices) {
      const [dateBefore] = [...service.dates];
      const {
        bestSchedule: { relations },
      } = service;
      await scheduleTypeOfServices(
        service,
        country,
        relations,
        orderData,
        true,
        false,
        null,
        null,
        null,
        null,
        schedulesToConsume,
      );
      const [dateAfter] = [...service.dates];
      data.addedDays += dayBetween(dateBefore, dateAfter);
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/scheduleOfDispatch.ts******
import boom from '@hapi/boom';
import {
  addDays,
  dateDiff,
  isAfter,
  isBetween,
} from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function scheduleOfDispatch(data = {} as any) {
  try {
    const { products, orderData = {} } = data;
    for (let i = 0; i < products.length; i++) {
      const { typeofServices } = products[i];
      for (let i1 = 0; i1 < typeofServices.length; i1++) {
        const {
          dates,
          holidays = {},
          bestSchedule: {
            _id,
            frecuency,
            schedule: { capacityByDay, init, end },
            unitMeasure,
            courierCode,
          },
        } = typeofServices[i1];
        let newDate = null;

        for (let dateIndex = 0; dateIndex < dates.length; dateIndex++) {
          const date = dates[dateIndex];
          const isAfterDay = isAfter(date, newDate);
          let diff = dateDiff(newDate, date) + 1;
          if (diff < 0) diff = 0;
          const daysToAdd = isAfterDay ? 0 : diff;
          newDate = dateIndex === 0 ? date : addDays(date, daysToAdd);
          newDate = await validDay(
            newDate,
            holidays[courierCode],
            frecuency,
            capacityByDay,
            init,
            end,
            {
              ...orderData,
              unitMeasure,
            },
          );
          dates[dateIndex] = newDate;
        }

        const newDates = deleteDatesOutOfRange({
          dates,
          from: init,
          to: end,
        });

        if (newDates.length === 0)
          throw new Error(
            `Agenda con ocurrencia fuera de rango. ID agenda: ${_id}`,
          );

        typeofServices[i1].dates = newDates;
        delete typeofServices[i1].bestSchedule.schedule.capacityByDay;
      }
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

function deleteDatesOutOfRange(data) {
  const { dates, from, to } = data;
  for (let dateIndex = 0; dateIndex < dates.length; dateIndex++) {
    const date = dates[dateIndex];
    const isBetweenDate = isBetween(date, from, to);
    if (!isBetweenDate) {
      dates.splice(dateIndex, 1);
      dateIndex -= 1;
    }
  }
  return dates;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/scheduleReception.ts******
import boom from '@hapi/boom';
import { receptionTypeOfServices } from '../../common/typeOfServicesFunctions';
import { dayBetween } from '../../../../infrastructure/helpers/date';

export async function scheduleReception(data) {
  try {
    const { products, country, orderData, isWithCalculationForMixedOrder } =
      data;

    for (const product of products) {
      const { typeofServices, schedulesToConsume } = product;
      for (const service of typeofServices) {
        const [dateBefore] = [...service.dates];
        const { bestSchedule } = service;

        await receptionTypeOfServices(
          service,
          country,
          bestSchedule.relations,
          orderData,
          false,
          null,
          null,
          null,
          null,
          null,
          schedulesToConsume,
        );
        const [dateAfter] = [...service.dates];
        data.addedDays += dayBetween(dateBefore, dateAfter);
      }
      if (!isWithCalculationForMixedOrder) break;
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/scheduleReceptionExceptDays.ts******
import boom from '@hapi/boom';
import { receptionTypeOfServices } from '../../common/typeOfServicesFunctions';
import { dayBetween } from '../../../../infrastructure/helpers/date';

export async function scheduleReceptionExceptDays(data) {
  try {
    const {
      products: [firstProduct],
      country,
      orderData,
    } = data;
    const { typeofServices, schedulesToConsume } = firstProduct;
    for (const service of typeofServices) {
      const [dateBefore] = [...service.dates];
      const { bestSchedule } = service;
      await receptionTypeOfServices(
        service,
        country,
        bestSchedule.relations,
        orderData,
        true,
        null,
        null,
        null,
        null,
        null,
        schedulesToConsume,
      );
      const [dateAfter] = [...service.dates];
      if (service.transferDates) {
        service.receptionDates = [...service.dates];
      }
      data.addedDays += dayBetween(dateBefore, dateAfter);
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/scheduleTransfer.ts******
import boom from '@hapi/boom';
import { scheduleTypeOfServices } from '../../common/typeOfServicesFunctions';
import {
  addDays,
  dayBetween,
  evaluateDatesArray,
  getDayNameFromDate,
  isOutOfCutTime,
  isSame,
  isSameOrAfter,
  lessDays,
} from '../../../../infrastructure/helpers/date';
import { getCacheClient } from '../../../../infrastructure/gateways/cacheClient';
import Office from '../../../common/schemas/Office';
import { validDay } from '../../common/validDay';
import Schedule from '../../../common/schemas/Schedule';
import Capacity from '../../../common/schemas/Capacity';
import { hasCapacityGenericForSchedules } from '../../common/hasCapacityGenericForSchedules';
import { isValidCapacity } from '../../../../infrastructure/helpers/schedule';
import { getObjectIdFromMongoose } from '../../../../infrastructure/helpers/mongoHelper';

export async function scheduleTransfer(data) {
  try {
    const { products, country, orderData, isWithCalculationForMixedOrder } =
      data;

    for (const product of products) {
      const { typeofServices, schedulesToConsume } = product;
      for (const service of typeofServices) {
        const [dateBefore] = [...service.dates];
        const { bestSchedule } = service;
        await scheduleTypeOfServices(
          service,
          country,
          bestSchedule.relations,
          orderData,
          false,
          false,
          null,
          null,
          null,
          null,
          schedulesToConsume,
        );
        const [dateAfter] = [...service.dates];
        data.addedDays += dayBetween(dateBefore, dateAfter);
        const setOfData = {
          storeId: service.bestSchedule.warehouse.storeId,
          id: service.id,
          holidays: service.holidays[service.bestSchedule.warehouse.storeCode],
          storeCode: service.bestSchedule.warehouse.storeCode,
        };
        fixDatePickingAndTransfer(
          setOfData,
          orderData,
          service.pickingDates,
          service.dates,
          service.log,
          service.holidays,
        );
      }
      if (!isWithCalculationForMixedOrder) break;
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

async function fixDatePickingAndTransfer(
  setOfData,
  orderDataArray,
  pickings,
  transfers,
  logs,
  holidays,
) {
  for (let index = 0; index < transfers.length; index++) {
    const transferDate = transfers[index];
    const pickingDate = pickings[index];
    let bufferDate = transferDate;
    if (logs) {
      const log = logs[Object.keys(logs)[index]];
      let exitStatus = true;
      const limitDate = getDateFromLog(log);
      const workDays = await getInternalWork(setOfData);
      if (workDays && workDays.internalWorkDays) {
        bufferDate = lessDays(bufferDate, workDays.internalWorkDays);
      }
      while (pickingDate < bufferDate && exitStatus && limitDate < bufferDate) {
        const validDate = await evaluateDatesArray(
          [bufferDate],
          0,
          holidays[setOfData.storeCode],
          validDay,
        );
        if (validDate) {
          bufferDate = lessDays(bufferDate, 1);
          const response = await getAvailablePickingSchedule(
            setOfData,
            orderDataArray,
            bufferDate,
          );
          if (response && limitDate < bufferDate) {
            changeLogsForFixPicking(
              validDate[0],
              bufferDate,
              log,
              workDays.internalWorkDays,
            );
            pickings[index] = bufferDate;
            exitStatus = false;
          } else {
            bufferDate = lessDays(bufferDate, 1);
          }
        }
      }
    }
  }
}

function getDateFromLog(logs) {
  const dateFrom = logs.find(
    (work) => work.functionName === 'Plazo de fabricación',
  );
  return new Date(dateFrom.date);
}

async function getInternalWork(setOfData) {
  const warehousesInternalWorkDays = await getCacheClient().wrapperQuery(
    `Office${[setOfData.storeCode].join('-')}`,
    async () =>
      Office.find(
        { storeCode: { $in: [setOfData.storeCode] } },
        { _id: 1, internalWorkDays: 1, storeCode: 1 },
        { lean: true },
      ),
  );
  return warehousesInternalWorkDays.find(
    (warehouseRule) => warehouseRule.storeCode === setOfData.storeCode,
  );
}

async function getAvailablePickingSchedule(
  setOfData,
  orderDataArray,
  dateElement,
) {
  let existPickingAvailable = false;
  const pickSchedule: any = await Schedule.findOne(
    {
      warehouses: getObjectIdFromMongoose(setOfData.storeId),
      services: getObjectIdFromMongoose(setOfData.id),
      'type.isPickingSchedule': true,
      active: true,
    },
    {
      _id: 1,
      active: 1,
      services: 1,
      warehouses: 1,
      capacities: 1,
      weekCutTime: 1,
      unitMeasure: 1,
      weekBaseCapacity: 1,
    },
    {},
  )
    .lean()
    .exec();

  if (pickSchedule) {
    const { capacityId } = pickSchedule.capacities.find(
      ({ warehouseId }) => warehouseId.toString() === setOfData.storeId,
    );
    const pickingCapacity = await Capacity.findOne(
      { _id: capacityId },
      { _id: 1, capacityByDayArray: 1 },
      {},
    )
      .lean()
      .exec();

    if (pickingCapacity) {
      let newDate = await validDay(dateElement, setOfData.holidays);
      for (const capacity of pickingCapacity.capacityByDayArray) {
        newDate = await validDay(newDate, setOfData.holidays);
        // if consulted day is same or after
        if (isSameOrAfter(capacity.day, newDate, 'day')) {
          // If has capacity
          const hasCapacity = hasCapacityGenericForSchedules(capacity, {
            ...orderDataArray,
            unitMeasure: pickSchedule.unitMeasure,
          });
          if (isValidCapacity(capacity) && hasCapacity) {
            // Check cuttime only when saleDate === newDate
            if (isSame(dateElement, newDate, null, 'day')) {
              const weekCutTime =
                pickSchedule.weekCutTime[getDayNameFromDate(capacity.day)];
              if (isOutOfCutTime(dateElement, weekCutTime)) {
                continue;
              }
            }
            existPickingAvailable = true;
            break;
          }
        }
      }
    }
  }
  return existPickingAvailable;
}

function changeLogsForFixPicking(internalDate, pickingDate, logs, workDate) {
  const internalWorkBuffer = logs.find(
    (work) => work.functionName === 'Trabajo interno',
  );
  const pickingScheduleBuffer = logs.find(
    (picking) => picking.functionName === 'Agenda de Picking',
  );
  const trfBuffer = logs.find(
    (trf) => trf.functionName === 'Fecha excepción TRF',
  );
  const newWorkDate = addDays(pickingDate, workDate);

  if (internalWorkBuffer && pickingScheduleBuffer) {
    internalWorkBuffer.date = newWorkDate.getTime();
    pickingScheduleBuffer.date = pickingDate.getTime();
    trfBuffer.date = internalWorkBuffer.date;
  }
  return logs;
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/slackByTypeOfService.ts******
import boom from '@hapi/boom';
import {
  dayBetween,
  evaluateDatesArray,
} from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function slackByTypeOfService(data = {} as any) {
  try {
    const {
      products: [firstProduct],
    } = data;
    const { typeofServices } = firstProduct;
    for (let i = 0; i < typeofServices.length; i++) {
      const {
        dates,
        slackDays,
        holidays = {},
        bestSchedule: { courierCode },
        joinedDayBycutTimeTypeOfService = false,
      } = typeofServices[i];
      const [firstDate] = dates;
      const daysToAdd =
        joinedDayBycutTimeTypeOfService && slackDays >= 1
          ? slackDays - 1
          : slackDays;
      typeofServices[i].dates = await evaluateDatesArray(
        dates,
        daysToAdd,
        holidays[courierCode],
        validDay,
      );
      data.addedDays += daysToAdd + dayBetween(firstDate, dates[0]);
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/slackOfHierarchy.ts******
import boom from '@hapi/boom';
import { getSlackDaysByPriority } from '../../common/getSlackDaysByPriority';
import { evaluateDatesArray } from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function slackOfHierarchy(data = {} as any) {
  try {
    const { products } = data;
    const [firstProduct] = products;
    let slackDaysToAdd = {};

    for (let i = 0; i < products.length; i++) {
      const {
        slackDays = 0,
        slackCourier,
        typeofServices,
        hierarchy,
      } = products[i];
      for (let i1 = 0; i1 < typeofServices.length; i1++) {
        const {
          bestSchedule: { courier },
          code,
        } = typeofServices[i1];

        const days = slackDaysToAdd[code] || 0;
        if (
          slackDays > 0 &&
          slackCourier &&
          String(courier) === String(slackCourier)
        ) {
          slackDaysToAdd = {
            ...slackDaysToAdd,
            [code]: slackDays > days ? slackDays : days,
          };
        } else {
          const slackDaysByPriority =
            getSlackDaysByPriority({ hierarchy, courier }) || 0;
          if (slackDaysByPriority > 0) {
            slackDaysToAdd = {
              ...slackDaysToAdd,
              [code]: slackDaysByPriority > days ? slackDaysByPriority : days,
            };
          }
        }
      }
    }

    for (
      let tosIndex = 0;
      tosIndex < firstProduct.typeofServices.length;
      tosIndex++
    ) {
      const {
        dates,
        holidays = {},
        code,
        bestSchedule: { courierCode },
      } = firstProduct.typeofServices[tosIndex];
      const days = slackDaysToAdd[code];
      if (days > 0) {
        firstProduct.typeofServices[tosIndex].dates = await evaluateDatesArray(
          dates,
          days,
          holidays[courierCode],
          validDay,
        );
      }
      firstProduct.typeofServices[tosIndex].dispatchDates = [...dates];
    }

    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}


// ****** Source: src/domains/schedule/services/scheduleCalculation/termLastMile.ts******
import boom from '@hapi/boom';
import { validDay } from '../../common/validDay';
import { addDays, dayBetween } from '../../../../infrastructure/helpers/date';

export async function termLastMile(data = {} as any) {
  try {
    const {
      products: [firstProduct],
    } = data;
    const { typeofServices } = firstProduct;
    for (let i = 0; i < typeofServices.length; i++) {
      const {
        dates,
        holidays = {},
        bestSchedule: { lastMile, lastMileFormat, courierCode },
      } = typeofServices[i];
      const [firstDate] = dates;
      for (let dateIndex = 0; dateIndex < dates.length; dateIndex++) {
        let newDate = dates[dateIndex];
        newDate = getDateByLastMileFormat({
          newDate,
          lastMile,
          lastMileFormat,
        });
        newDate = await validDay(newDate, holidays[courierCode]);
        dates[dateIndex] = newDate;
      }
      data.addedDays += dayBetween(firstDate, dates[0]);
      typeofServices[i].dates = dates;
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

const getDateByLastMileFormat = (data) => {
  const { newDate, lastMile, lastMileFormat } = data;
  let newDateByLastMileFormat = newDate;
  switch (lastMileFormat.id) {
    case 1:
      newDateByLastMileFormat = addDays(newDate, Number(lastMile));
      break;
    case 2:
      newDateByLastMileFormat.setHours(newDate.getHours() + Number(lastMile));
      break;
    default:
      break;
  }
  return newDateByLastMileFormat;
};


// ****** Source: src/domains/schedule/services/scheduleCalculation/transferRelation.ts******
import boom from '@hapi/boom';
import {
  dayBetween,
  evaluateDatesArray,
} from '../../../../infrastructure/helpers/date';
import { validDay } from '../../common/validDay';

export async function transferRelation(data) {
  try {
    const {
      products: [firstProduct],
    } = data;
    const { typeofServices } = firstProduct;
    for (const service of typeofServices) {
      const {
        bestSchedule,
        bestSchedule: {
          courierCode,
          relations,
          warehouse: { storeCode },
        },
        dates,
        holidays = {},
      } = service;
      const directDays = findDirectRelation(bestSchedule, relations);

      const isDistinct = courierCode !== storeCode;

      if (directDays >= 0) {
        if (isDistinct) {
          service.transferDates = [...dates];
          const newDates = await evaluateDatesArray(
            dates,
            directDays,
            holidays[courierCode],
            validDay,
          );
          service.transferDays = dayBetween(
            new Date(dates[0]),
            new Date(newDates[0]),
          );
          data.addedDays += service.transferDays;
          service.dates = newDates;
        }
      }
    }
    return data;
  } catch (err) {
    throw boom.boomify(err);
  }
}

function findDirectRelation(bestSchedule, transferData) {
  if (
    transferData.length === 2 &&
    bestSchedule.warehouse.storeId === transferData[0].id &&
    transferData[1].id === bestSchedule.courier
  ) {
    return transferData[1].transferPeriod;
  }
  return 0;
}


// ****** Source: src/domains/shipping/controllers/index.ts******
import { Request, Response, NextFunction } from 'express';
import responseManager from '../../../infrastructure/common/responseManager';
import { Controller, Post } from '../../../types/decorators';
import { Product } from '../entities/Product';
import { getConsolidatedOrderByOpl } from '../services/getConsolidatedOrder';
import { GetShippingRatesLegacyRequestDto } from '../entities/GetShippingRatesLegacyRequestDto';
import { shippingRatesLegacy } from '../services/getShippingRatesLegacy';

@Controller('/shipping')
export default class ShippingController {
  @Post('/opl/consolidation')
  public getConsolidationByOpl = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const products: Product[] = request.body;
      const order = await getConsolidatedOrderByOpl(products);
      responseManager(response, order);
    } catch (error) {
      next(error);
    }
  };
  @Post('/rates/legacy')
  public getShippingRatesLegacyController = async (
    request: Request,
    response: Response,
    next: NextFunction,
  ) => {
    try {
      const shippingRatesRequest: GetShippingRatesLegacyRequestDto =
        request.body;
      const result = await shippingRatesLegacy(shippingRatesRequest);
      responseManager(response, result);
    } catch (error) {
      next(error);
    }
  };
}


// ****** Source: src/domains/shipping/entities/GetShippingRatesLegacyRequestDto.ts******
export type GetShippingRatesLegacyRequestDto = ShippingRateRequest[];

type ShippingRateRequest = {
  localityId: string;
  country: string;
  salesChannelCode: string;
  typeOfService: string;
  courierId: string;
  stockSourceId: string;
  products: Product[];
};

type Product = {
  sku: number;
  volume: number;
  quantity: string;
  size: string;
};


// ****** Source: src/domains/shipping/entities/Product.ts******
export type Product = {
  sku: string;
  quantity: string;
  size: string;
  volume: number;
  isLegacyRequest: boolean;
  bestSchedules: BestSchedule[];
  typeofServices: TypeOfService[];
};

type BestSchedule = {
  _id: string;
  courierCode: string;
  courier: string;
  volumeMin: Volume;
  volumeMax: Volume;
  warehouse: Warehouse;
  priorityByHierarchy: PriorityByHierarchy;
};

type Volume = {
  id: string;
  label: string;
  code: string;
  country: string;
  cubicCapacityFrom: number;
  cubicCapacityTo: number;
  isDisabledEdit: boolean;
};

type Warehouse = {
  storeCode: string;
  storeId: string;
  storeType: string;
};

type PriorityByHierarchy = {
  typeOfServiceName: string;
  hierarchyName: string;
  hierarchyCode: string;
  priority: number;
};

type TypeOfService = {
  id: string;
  code: string;
  label: string;
  cutTime: CutTime[];
  isActive: boolean;
  delivery: Delivery;
  description: string;
  slackDays: number;
  channelSale: ChannelSale[];
  maxOcurrence: number;
  enabledForCheckout: boolean;
  serviceGroup: string;
  date: string;
  dates: string[];
  bestSchedule: ServiceBestSchedule;
};

type CutTime = {
  value: string;
  id: number;
  label: string;
};

type Delivery = {
  _id: string;
  code: string;
  description: string;
  creationDate: string;
  __v: number;
};

type ChannelSale = {
  id: number;
  label: string;
};

type ServiceBestSchedule = {
  _id: string;
  frecuency: number[];
  activeCommunesOrDistricts: ActiveCommunesOrDistricts[];
  lastMile: number;
  lastMileFormat: LastMileFormat;
  volumeMin: Volume;
  volumeMax: Volume;
  country: string;
  unitMeasure: string;
  courierCode: string;
  courierName: string;
  courier: string;
  mainWizard: string;
  mainZone: string;
  mainSchedule: string;
  __v: number;
  updatedAt: string;
  priorityByHierarchy: PriorityByHierarchy;
  relations: Relation[];
  schedule: Schedule;
  warehouse: ServiceWarehouse;
};

type ActiveCommunesOrDistricts = {
  id: string;
  label: string;
  isActive: boolean;
};

type LastMileFormat = {
  id: number;
  label: string;
};

type Relation = {
  sequence: number;
  id: string;
  courier: string;
  internalWorkDays: number;
  label: string;
  code: string;
  transferPeriod?: number;
};

type Schedule = {
  typeofServices: ScheduleTypeOfService[];
  init: string;
  end: string;
  capacity: Capacity[];
  cutTime: CutTime[];
};

type Capacity = {
  id: number;
  label: string;
  value: string;
};

type ServiceWarehouse = {
  storeId: string;
  storeCode: string;
  storeName: string;
  storeType: string;
  isValid: boolean;
  typeofServices: string[];
  channelSalesCode: string[];
};

type ScheduleTypeOfService = {
  id: string;
  code: string;
  label: string;
  cutTime: CutTime[];
  isActive: boolean;
  delivery: string;
  description: string;
  slackDays: number;
  channelSale: ChannelSale[];
  maxOcurrence: number;
};


// ****** Source: src/domains/shipping/entities/constants.ts******
export enum ImsErrors {
  NoStock = 'Sin stock en IMS',
  SkuNotFound = 'Sku no encontrado en IMS',
}

export enum SicErrors {
  NoStock = 'Sin stock en SIC',
  SkuNotFound = 'Sku no encontrado en SIC',
}

export enum ScheduleErrors {
  NoDateRange = 'Fecha fuera de rango',
  NoCommuneOrDistrict = 'Comuna/distrito sin ruta',
  NoSize = 'El tamaño del producto no es transportable por el opl',
  NoSchedule = 'No se ha encontrado agenda para esa comuna/distrito',
  NoCoverage = 'No hay cobertura y/o Tamaño del producto fuera de rango',
  NoActiveServiceType = 'Agenda/ruta no tiene el tipo de servicio activado',
  NoScheduleCapacity = 'No se ha encontrado capacidad de agenda de transferencia para sucursal de stock:',
  NoClusterOpl = 'No se ha encontrado clúster para OPL:',
  NoScheduleWarehouse = 'No se ha encontrado capacidad para agenda de transferencia warehouse:',
  NoScheduleReceptionCapacity = 'No se ha encontrado capacidad para agenda de recepción sucursal:',
  NoScheduleReception = 'No se ha encontrado agenda de recepción para sucursal de stock:',
  NoRoute = 'Debe activar ruta de transferencia para:',
  NoTransfer = 'No se han configurado transferencias entre sucursales correspondiente',
}

export enum DeliveryMethods {
  StorePickup = 'RT',
  DispatchDelivery = 'DP',
}

export enum ServiceKey {
  PDP = 'BLOGIC-PDP',
  CHECKOUT = 'BLOGIC-CHECKOUT',
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/filterSchedulesByVolume.ts******
export function filterSchedulesByVolume(typeofServices, sizeOrder) {
  const newBestSchedules = typeofServices.filter(
    ({
      bestSchedule: {
        volumeMax: { code: sizeMax },
        volumeMin: { code: sizeMin },
      },
    }) =>
      Number(sizeMax) >= Number(sizeOrder) &&
      Number(sizeOrder) >= Number(sizeMin),
  );
  return newBestSchedules;
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/findProductsToTransport.ts******
import { filterSchedulesByVolume } from './filterSchedulesByVolume';

export function findProductsToTransport(bestSchedulesFromProducts, products) {
  const isLegacyRequest = products.some((p) => p.isLegacyRequest === true);

  for (const bestSchedule of bestSchedulesFromProducts) {
    let productsForOrder = [];
    let quantityProducts = 0;
    for (const product of products) {
      const { size, sku, bestSchedules } = product;
      const [bestSchedulesByOrder] = filterSchedulesByVolume(
        [{ bestSchedule }],
        size,
      );
      const isContainsProduct = isBestScheduleContainsProduct(
        bestSchedulesByOrder ? bestSchedulesByOrder.bestSchedule : null,
        bestSchedules,
        isLegacyRequest,
      );
      if (isContainsProduct) {
        productsForOrder = [...productsForOrder, sku];
        quantityProducts += 1;
      }
    }
    bestSchedule.productsForTransport = {
      quantityProducts,
      productsForOrder,
    };
  }
  return bestSchedulesFromProducts;
}

function isBestScheduleContainsProduct(
  bestSchedule,
  productBestSchedules,
  isLegacyRequest,
) {
  if (!bestSchedule) return false;
  const { _id, courierCode, warehouse } = bestSchedule;
  if (isLegacyRequest)
    return productBestSchedules.some((schedule) => schedule._id === _id);
  return productBestSchedules.some(
    (schedule) =>
      schedule._id === _id &&
      schedule.courierCode === courierCode &&
      schedule.warehouse.storeCode === warehouse.storeCode,
  );
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getBestPriorityByOplOrder.ts******
import min from 'lodash/min';

export function getBestPriorityByOplOrder(bestSchedulesByOrder) {
  if (bestSchedulesByOrder.length === 0) return [];
  const bestPriority = min(
    bestSchedulesByOrder.map((bs) => bs.priorityByHierarchy.priority),
  );
  return bestSchedulesByOrder.filter(
    (bs) => bs.priorityByHierarchy.priority === bestPriority,
  );
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getBestSchedulesFromProducts.ts******
import uniqBy from 'lodash/uniqBy';

export function getBestSchedulesFromProducts(products) {
  const bestSchedulesFromProducts = products.flatMap((product) =>
    product.bestSchedules.map((bestSchedule) => ({
      ...bestSchedule,
      courierWarehouseCode: `${bestSchedule.courierCode}${bestSchedule.warehouse.storeCode}`,
    })),
  );
  return uniqBy(bestSchedulesFromProducts, 'courierWarehouseCode');
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getConsolidateSimpleProduct.ts******
import groupBy from 'lodash/groupBy';
import { filterSchedulesByVolume } from './filterSchedulesByVolume';

export function getConsolidateSimpleProduct(products) {
  let order = [];
  const [product] = products;
  const { typeofServices, size } = product;
  const bestSchedulesByOrder = filterSchedulesByVolume(typeofServices, size);
  const groupedTypeOfServices = groupBy(
    bestSchedulesByOrder,
    groupTypeOfServicesByWarehouseOpl,
  );

  if (Object.values(groupedTypeOfServices).length > 0) {
    order = orderGroupedTypeOfServices(groupedTypeOfServices).map((item) => ({
      products: [
        {
          ...product,
          typeofServices: item,
        },
      ],
    }));
  }
  return order;
}

function groupTypeOfServicesByWarehouseOpl(typeOfService) {
  const {
    bestSchedule: { warehouse },
  } = typeOfService;
  return `${warehouse.storeCode}`;
}

function orderGroupedTypeOfServices(groupedTypeOfServices) {
  const warehousesGroup = Object.values(groupedTypeOfServices);
  const oplsResult = warehousesGroup.map((warehouseGroup: Array<any>) => {
    if (warehouseGroup.length === 1) return warehouseGroup;
    warehouseGroup.sort((a, b) => {
      const aPriority = a.bestSchedule.priorityByHierarchy.priority;
      const bPriority = b.bestSchedule.priorityByHierarchy.priority;
      return Number(aPriority) - Number(bPriority);
    });
    return warehouseGroup.filter(
      (x) =>
        x.bestSchedule.courierCode ===
        warehouseGroup[0].bestSchedule.courierCode,
    );
  });

  oplsResult.sort((a, b) => {
    const aPriority = a.reduce(reducePriority, 0);
    const bPriority = b.reduce(reducePriority, 0);
    return Number(aPriority) - Number(bPriority);
  });

  return oplsResult;
}

function reducePriority(acc, val, index) {
  const { priority } = val.bestSchedule.priorityByHierarchy;
  if (index === 0) return priority;
  return Math.min(acc, priority);
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getConsolidatedWarehouses.ts******
import uniq from 'lodash/uniq';
import intersection from 'lodash/intersection';

export function getConsolidatedWarehouses(products) {
  const newProducts = [];
  let isConsolidated = false;

  const newProductsWithWarehouses = products.map((p) => {
    const newWarehouses = [];
    p.typeofServices.forEach((tos) => {
      newWarehouses.push(tos.bestSchedule.warehouse.storeCode);
    });
    newProducts.push(newWarehouses);
    const [newWarehouse] = uniq(newWarehouses);
    return {
      ...p,
      newWarehouse,
    };
  });

  const consolidatedWarehouses = intersection(...newProducts);
  if (consolidatedWarehouses.length > 0) isConsolidated = true;
  let matrixes = [{ products }];

  if (!isConsolidated) {
    const productsByMatrix = Object.values(
      newProductsWithWarehouses.reduce(
        (productsWarehousesGroup, newProduct) => {
          const productsByWarehouse = products.reduce((productsGroup, p) => {
            const hasWarehouse = p.typeofServices.some(
              (tos) =>
                tos.bestSchedule.warehouse.storeCode ===
                newProduct.newWarehouse,
            );
            if (hasWarehouse) return [...productsGroup, p];
            return productsGroup;
          }, []);
          return {
            ...productsWarehousesGroup,
            [`${newProduct.newWarehouse}`]: productsByWarehouse,
          };
        },
        {},
      ),
    );
    matrixes = productsByMatrix.map((productsInMatrix) => ({
      products: productsInMatrix,
    }));
  }

  return {
    matrixes,
    isConsolidated,
    consolidatedWarehouses,
  };
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getMatrixFromProducts.ts******
export function getMatrixFromProducts(data) {
  const { products, newBestSchedule } = data;
  let matrixFromProducts = {};
  for (let indexProduct = 0; indexProduct < products.length; indexProduct++) {
    const { bestSchedules, typeofServices } = products[indexProduct];
    for (
      let indexSchedule = 0;
      indexSchedule < bestSchedules.length;
      indexSchedule++
    ) {
      const bestSchedule = bestSchedules[indexSchedule];
      if (bestSchedule.courierCode === newBestSchedule.courierCode) {
        matrixFromProducts = {
          typeofServices: getTypeOfServicesFromBestSchedule(
            typeofServices,
            newBestSchedule.courierCode,
          ),
        };
        break;
      }
    }
  }
  return matrixFromProducts;
}

function getTypeOfServicesFromBestSchedule(typeofServices, courierCode) {
  let newTypeofServices = [];
  for (
    let indexServices = 0;
    indexServices < typeofServices.length;
    indexServices++
  ) {
    const { bestSchedule } = typeofServices[indexServices];
    if (bestSchedule.courierCode === courierCode) {
      newTypeofServices = [
        ...newTypeofServices,
        {
          ...typeofServices[indexServices],
        },
      ];
    }
  }
  return newTypeofServices;
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getSkusFromOrder.ts******
export function getSkusFromOrder(products) {
  const skus = products.map((product) => product.sku);
  return skus;
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/getTypeOfServicesByPriority.ts******
import { DeliveryMethods } from '../../entities/constants';

export function getTypeOfServicesByPriority(
  priorityByTypeOfService,
  product,
  consolidated,
) {
  const { isConsolidated, consolidatedWarehouses } = consolidated;
  const isStorePickup = product.typeofServices.some(
    (tos) => tos.delivery?.code === DeliveryMethods.StorePickup,
  );
  if (isStorePickup && !isConsolidated) return product.typeofServices;

  if (isStorePickup && isConsolidated) {
    return [
      ...priorityByTypeOfService.reduce((acc, item) => {
        if (item.products.some((p) => p.sku === product.sku)) {
          return [
            ...acc,
            ...item.typeofServices.filter((tos) =>
              consolidatedWarehouses.includes(
                tos.bestSchedule.warehouse.storeCode,
              ),
            ),
          ];
        }
        return acc;
      }, []),
    ];
  }

  return [
    ...priorityByTypeOfService.reduce((acc, item) => {
      if (item.products.some((p) => p.sku === product.sku)) {
        return [...acc, ...item.typeofServices];
      }
      return acc;
    }, []),
  ];
}


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/index.ts******
import { Product } from '../../entities/Product';
import { findProductsToTransport } from './findProductsToTransport';
import { getBestPriorityByOplOrder } from './getBestPriorityByOplOrder';
import { getBestSchedulesFromProducts } from './getBestSchedulesFromProducts';
import { getConsolidateSimpleProduct } from './getConsolidateSimpleProduct';
import { getConsolidatedWarehouses } from './getConsolidatedWarehouses';
import { getMatrixFromProducts } from './getMatrixFromProducts';
import { getSkusFromOrder } from './getSkusFromOrder';
import { getTypeOfServicesByPriority } from './getTypeOfServicesByPriority';
import { filterSchedules, seekConsolidateOrder } from './seekConsolidateOrder';

export const getConsolidatedOrderByOpl = async (products: Product[]) => {
  let order = [];
  let priorityByTypeOfService = [];

  // Seeks to consolidate the order of a single product
  if (products.length === 1) {
    order = getConsolidateSimpleProduct(products);
    return order;
  }

  let bestSchedulesFromProducts = getBestSchedulesFromProducts(products);

  // Find the amount of products that each opl can transport
  bestSchedulesFromProducts = findProductsToTransport(
    bestSchedulesFromProducts,
    products,
  );

  const skusFromOrder = getSkusFromOrder(products);

  // Sort list from lowest to highest priority of opl
  bestSchedulesFromProducts.sort(
    (a, b) => a.priorityByHierarchy.priority - b.priorityByHierarchy.priority,
  );

  // Seeks to consolidate the order of several products in one opl
  let oplOrdersToPrioritize = [];
  oplOrdersToPrioritize = seekConsolidateOrder(
    bestSchedulesFromProducts,
    products,
    skusFromOrder,
  );

  // Gets the opl that takes priority
  if (oplOrdersToPrioritize.length > 0) {
    const newOplOrdersToPrioritize = oplOrdersToPrioritize.filter(
      (item) => item.products.length === products.length,
    );
    if (newOplOrdersToPrioritize.length === 0) {
      return order;
    }
    priorityByTypeOfService = getBestPriorityByOplOrder(
      newOplOrdersToPrioritize,
    );
    const consolidatedByWarehouse = getConsolidatedWarehouses(products);
    order = consolidatedByWarehouse.matrixes.map((matrix) => ({
      products: matrix.products.map((product) => ({
        ...product,
        typeofServices: getTypeOfServicesByPriority(
          priorityByTypeOfService,
          product,
          consolidatedByWarehouse,
        ),
        isConsolidatedByWarehouse: consolidatedByWarehouse.isConsolidated,
      })),
    }));

    return order;
  }

  // Seeks to consolidate the order of several products in several opl
  if (oplOrdersToPrioritize.length === 0) {
    // Consolidated the order in more than one opl
    if (bestSchedulesFromProducts.length > 1) {
      // filter schedules with bigger groups and lower priority
      const filteredSchedules = filterSchedules(
        bestSchedulesFromProducts,
        skusFromOrder,
      );

      for (const newBestSchedule of filteredSchedules) {
        const productsData = products.filter((p) =>
          newBestSchedule.productsForTransport.productsForOrder.includes(p.sku),
        );

        const { typeofServices: typeofServicesByGroup }: any =
          getMatrixFromProducts({ products: productsData, newBestSchedule });

        order = [
          ...order,
          {
            products: productsData.map((product) => {
              const { typeofServices: typeofServicesByproduct } = product;
              const typeofServicesByProductFilter =
                typeofServicesByGroup.filter(({ id: idGroup }) =>
                  typeofServicesByproduct.find(({ id }) => id === idGroup),
                );
              return {
                ...product,
                typeofServices: typeofServicesByProductFilter,
              };
            }),
          },
        ];
      }
    }
  }

  // Consolidate common service types
  return order;
};


// ****** Source: src/domains/shipping/services/getConsolidatedOrder/seekConsolidateOrder.ts******
import LogHandler from '../../../../infrastructure/common/handlers/logHandler';
import { getMatrixFromProducts } from './getMatrixFromProducts';

type Schedule = {
  _id: string;
  courierWarehouseCode: string;
  priorityByHierarchy: {
    priority: number;
  };
  productsForTransport: { productsForOrder: string[] };
};

type ConsolidationOption = {
  schedules: Schedule[];
  priorities: number[];
  productsGroups: string[][];
  courierWarehousesCodes: string[];
};

export function seekConsolidateOrder(
  bestSchedulesFromProducts,
  products,
  skusFromOrder,
) {
  let newBestSchedules = {};
  let oplOrdersToPrioritize = [];
  for (
    let indexSchedule = 0;
    indexSchedule < bestSchedulesFromProducts.length;
    indexSchedule++
  ) {
    const {
      _id,
      courier,
      courierCode,
      priorityByHierarchy,
      productsForTransport: { productsForOrder },
    } = bestSchedulesFromProducts[indexSchedule];
    // eslint-disable-next-line no-loop-func
    const isProductsInOrder = skusFromOrder.every((sku) =>
      productsForOrder.includes(sku),
    );
    if (isProductsInOrder) {
      newBestSchedules = bestSchedulesFromProducts[indexSchedule];
      const { typeofServices }: any = getMatrixFromProducts({
        products,
        newBestSchedule: { ...newBestSchedules },
      });

      oplOrdersToPrioritize = [
        ...oplOrdersToPrioritize,
        {
          _id,
          courier,
          courierCode,
          priorityByHierarchy,
          typeofServices,
          // eslint-disable-next-line no-loop-func
          products: products.map((product) => ({
            ...product,
            typeofServices,
          })),
        },
      ];
    }
  }
  return oplOrdersToPrioritize;
}

export const filterSchedules = (
  bestSchedulesFromProducts: Schedule[],
  skusFromOrder,
) => {
  if (bestSchedulesFromProducts.length === 0) {
    return [];
  }
  const groups = findBestCombination(bestSchedulesFromProducts, skusFromOrder);

  const filteredGroups = groups.filter(
    (group, index, self) =>
      index ===
      self.findIndex((t) =>
        t.courierWarehousesCodes.every((code) =>
          group.courierWarehousesCodes.includes(code),
        ),
      ),
  );

  LogHandler.info({
    action: 'CONSOLIDATION_GROUPS_RESULT',
    details: {
      groups: [
        ...filteredGroups.map((group) => ({
          ...group,
          schedules: group.schedules.map((schedule) => schedule._id),
        })),
      ],
    },
  });

  const schedulesFromGroups = filteredGroups.reduce((acc, group) => {
    group.schedules.forEach((schedule) => {
      if (!acc.includes(schedule)) acc.push(schedule);
    });
    return acc;
  }, []);

  return schedulesFromGroups;
};

const findBestCombination = (schedules: Schedule[], products: string[]) => {
  if (schedules.length === 0 || products.length === 0) {
    return [
      {
        schedules: [],
        priorities: [],
        productsGroups: [],
        courierWarehousesCodes: [],
      },
    ] as ConsolidationOption[];
  }

  const sortedSchedules = orderProductsBySchedule(schedules);
  const minimalPriorityFromBiggerGroup =
    sortedSchedules[0].priorityByHierarchy.priority;
  const maxProductsInSchedule =
    sortedSchedules[0].productsForTransport.productsForOrder.length;
  const candidateSchedules = sortedSchedules.filter(
    (schedule) =>
      schedule.priorityByHierarchy.priority ===
        minimalPriorityFromBiggerGroup &&
      schedule.productsForTransport.productsForOrder.length ===
        maxProductsInSchedule,
  );

  let results: ConsolidationOption[] = [];
  for (const candidate of candidateSchedules) {
    const productsConsolidated = [
      ...candidate.productsForTransport.productsForOrder,
    ];
    const productsToStillConsolidate = products.filter(
      (product) => !productsConsolidated.includes(product),
    );

    const restOfSchedules = schedules.filter(
      (schedule) => schedule._id !== candidate._id,
    );

    const remainingSchedules = reorderSchedulesRemovingProducts(
      restOfSchedules,
      productsConsolidated,
    );
    const combinations = findBestCombination(
      remainingSchedules,
      productsToStillConsolidate,
    );
    for (const combination of combinations) {
      results.push({
        schedules: [candidate, ...combination.schedules],
        priorities: [
          candidate.priorityByHierarchy.priority,
          ...combination.priorities.map((priority) => priority),
        ],
        productsGroups: [
          productsConsolidated,
          ...combination.productsGroups.map((product) => product),
        ],
        courierWarehousesCodes: [
          candidate.courierWarehouseCode,
          ...combination.courierWarehousesCodes.map((code) => code),
        ],
      });
    }
  }

  return results;
};

const reorderSchedulesRemovingProducts = (
  schedules: Schedule[],
  productsToRemove: string[],
): Schedule[] => {
  const newSchedules = schedules.reduce((acc, schedule) => {
    const newProductsForOrder =
      schedule.productsForTransport.productsForOrder.filter(
        (product) => !productsToRemove.includes(product),
      );

    if (newProductsForOrder.length > 0) {
      acc.push({
        ...schedule,
        productsForTransport: {
          productsForOrder: newProductsForOrder,
        },
      });
    }

    return acc;
  }, []);

  return orderProductsBySchedule(newSchedules);
};

const orderProductsBySchedule = (schedules: Schedule[]): Schedule[] => {
  const newSchedules = [...schedules];
  newSchedules.sort((a, b) => {
    const diff =
      b.productsForTransport.productsForOrder.length -
      a.productsForTransport.productsForOrder.length;
    if (diff !== 0) return diff;
    return a.priorityByHierarchy.priority - b.priorityByHierarchy.priority;
  });
  return newSchedules;
};


// ****** Source: src/domains/shipping/services/getShippingRatesLegacy/getOneShippingRateLegacy.ts******
import { getCacheClient } from '../../../../infrastructure/gateways/cacheClient';
import {
  getCountryId,
  getObjectIdFromMongoose,
} from '../../../../infrastructure/helpers/mongoHelper';
import Commune from '../../../common/schemas/Commune';
import Size from '../../../common/schemas/Size';
import { uniq, max, cloneDeep, isNil } from 'lodash';
import { ExtendedError } from '../../../../infrastructure/common/exceptions/ExtendedError';
import ShippingRates from '../../../common/schemas/ShippingRates';
import Cargoskus from '../../../common/schemas/Cargoskus';

export async function getOneShippingRateLegacy(data) {
  const {
    courierId,
    stockSourceId,
    localityId,
    typeOfService,
    products,
    country,
    salesChannelCode,
  } = data;

  const responseData = {
    products: [],
    errors: [],
  };

  try {
    const sizesPromise = getCacheClient().wrapperQuery(
      `${country}Sizes`,
      async () =>
        Size.find({
          country: getObjectIdFromMongoose(getCountryId[country]),
        })
          .select('-description -createdAt -updatedAt -__v -type -user')
          .sort({ order: 'asc' })
          .lean(),
    );

    const communePromise = getCacheClient().wrapperQuery(
      `${country}CommuneByIdWithRegionCode:${localityId}`,
      async () =>
        Commune.findOne(
          { _id: getObjectIdFromMongoose(localityId) },
          { region: 1 },
        )
          .populate({ path: 'region', select: 'code' })
          .lean(),
    );

    const [sizes, commune] = await Promise.all([sizesPromise, communePromise]);

    const mandatorySize = getMandatorySize(products, sizes);

    const findOneShippingRatesQuery = {
      countryCode: country,
      commune: getObjectIdFromMongoose(localityId),
      courier: getObjectIdFromMongoose(courierId),
      warehouse: getObjectIdFromMongoose(stockSourceId),
      service: getObjectIdFromMongoose(typeOfService),
      size: mandatorySize._id,
      channelSale: salesChannelCode,
    };

    const shippingRates = await ShippingRates.findOne(
      findOneShippingRatesQuery,
      {
        rates: 1,
      },
    ).lean();

    if (isNil(shippingRates) || !shippingRates.rates.length) {
      throw new ExtendedError(
        'No existe tarifa de despacho',
        findOneShippingRatesQuery,
      );
    }

    let cargoSkusTotal = 0;

    const productPromises = products.map(async (product) => {
      const { quantity, sku, size } = product;

      cargoSkusTotal += getCargoSkuQuantityByMandatorySize(
        size,
        mandatorySize,
        sizes,
        quantity,
      );

      const rates = await matchRates(shippingRates, country, commune);

      if (rates.length === 0) {
        throw new ExtendedError('No se encontró la tarifa de despacho', {
          ...data,
          size: mandatorySize.name,
        });
      }

      return {
        sku,
        quantity,
        rates,
        resolvedSize: mandatorySize.name,
      };
    });

    responseData.products = await Promise.all(productPromises);

    responseData.products = responseData.products.map((p) => {
      p.shippingSkuQuantity = Math.ceil(
        cargoSkusTotal / mandatorySize.quantityFactor,
      );
      return p;
    });
  } catch (error) {
    responseData.errors.push({
      msg: error.message,
      data: error.data,
    });
  }

  return {
    ...responseData,
    typeOfService,
    stockSourceId,
    courierId,
  };
}

function getMandatorySize(products, sizes) {
  const sizesIds = uniq(products.map((p) => p.size));
  const sizeIndexes = [];
  sizesIds.forEach((sId) => {
    const sizeIndex = sizes.findIndex((item) => String(item._id) === sId);
    sizeIndexes.push(sizeIndex);
  });
  return sizes[max(sizeIndexes)];
}

function getCargoSkuQuantityByMandatorySize(
  sizeId,
  mandatorySize,
  sizes,
  productsQuantity,
) {
  if (sizeId === String(mandatorySize._id)) return productsQuantity;
  const sizeIndex = sizes.findIndex((s) => String(s._id) === sizeId);
  const mandatoryIndex = sizes.findIndex(
    (s) => String(s._id) === String(mandatorySize._id),
  );

  let cargoSkuQuantity = productsQuantity;

  sizes.forEach((size, index) => {
    if (index < sizeIndex || index >= mandatoryIndex) return;
    cargoSkuQuantity = Math.floor(
      cargoSkuQuantity / size.higherEquivalenceFactor,
    );
  });
  return cargoSkuQuantity;
}

async function matchRates(shippingRates, country, commune) {
  const originalRates = cloneDeep(shippingRates.rates);
  let rates = await matchPriceByCargoSkuCode(originalRates, country);
  if (rates.length === 0) {
    rates = await matchCargoSkuCodeByPrice(
      originalRates,
      country,
      commune.region.code,
    );
  }
  return rates;
}

async function matchPriceByCargoSkuCode(rates, country) {
  const cargoSkuPromises = rates.map(async (rate) => {
    if (!rate.cargoSku) return Promise.resolve(null);
    return getCargoSku(country, Number(rate.cargoSku));
  });

  const cargoSkus = (await Promise.all(cargoSkuPromises)).filter(Boolean);
  if (!cargoSkus.length) return [];

  const newRates = rates
    .map((rate) => {
      const { price } = cargoSkus.find(
        (cargo) => cargo.code === rate.cargoSku,
      ) || { price: null };
      const newPrice = country === 'PE' ? Number(price) : price;
      return price != null
        ? {
          ...rate,
          price: newPrice,
        }
        : null;
    })
    .filter(Boolean);

  return newRates;
}

async function getCargoSku(countryCode, code) {
  return Cargoskus.findOne(
    {
      countryCode,
      code,
    },
    { price: 1, code: 1 },
  )
    .lean()
    .exec();
}

async function matchCargoSkuCodeByPrice(rates, country, regionCode) {
  const prices = uniq([
    ...rates.map(({ price = null }) => price).filter((price) => price != null),
  ]);
  const cargoSkus = await Cargoskus.find(
    {
      countryCode: country,
      region: { $in: [regionCode, null] },
      price: { $in: prices },
    },
    { price: 1, region: 1, code: 1 },
  );

  if (!cargoSkus.length) {
    throw new ExtendedError('No se encontró sku flete', {
      country,
      regionCode,
      price: prices,
    });
  }

  return rates
    .map((rate) => {
      const cargoSkuValid = cargoSkus.find(
        (cargoSku) => cargoSku.price === rate.price && cargoSku.region,
      );

      const cargoSkuError = cargoSkus.find(
        (cargoSku) => cargoSku.price === rate.price && cargoSku.region === null,
      );

      if (!cargoSkuValid && !cargoSkuError) {
        // FIXME: será un return null?
        null;
      }
      const cargoSku = cargoSkuValid.code || cargoSkuError.code;

      return {
        ...rate,
        cargoSku,
      };
    })
    .filter(Boolean);
}


// ****** Source: src/domains/shipping/services/getShippingRatesLegacy/index.ts******
import { getOneShippingRateLegacy } from './getOneShippingRateLegacy';

export async function shippingRatesLegacy(data) {
  const promises = data.map((item) => getOneShippingRateLegacy(item));
  const results = await Promise.all(promises);
  return results;
}


// ****** Source: src/index.ts******
import * as env from './infrastructure/common/env';
import apm from './infrastructure/common/apm';
apm.start();
import Server from './infrastructure/server';
import connect from './infrastructure/repositories/mongoConnector';
import { initCacheClient } from './infrastructure/gateways/cacheClient';

if (env.MONGO_URI) connect();
if (env.REDIS_CONFIG) initCacheClient();

export default new Server().listen(env.PORT);


// ****** Source: src/infrastructure/common/apm.ts******
import apm from 'elastic-apm-node';
import logger from './logger';
import { APP_ID } from './env';

const start = () => {
  const apmCaptureHeaders = `${process.env.APM_CAPTURE_HEADERS}`;
  const apmAbortedRequests = `${process.env.APM_ERROR_ABORTED_REQUESTS}`;
  const apmEnabled = `${process.env.ELASTIC_APM_ACTIVE}`;

  if (apmEnabled === 'true') {
    try {
      const apmInstance = apm.start({
        serviceName: APP_ID,
        captureHeaders: Boolean(apmCaptureHeaders),
        errorOnAbortedRequests: Boolean(apmAbortedRequests),
        captureBody: 'off',
        ignoreUrls: ['/', '/health'],
        logger,
      });
      logger.info(
        `APM Initialized: ${apmInstance.getServiceName()} in APM server ${
          process.env.ELASTIC_APM_SERVER_URL
        }`,
      );
    } catch (error) {
      logger.warn(`APM error - ${error.message}`);
    }
  }
};

export default { start };


// ****** Source: src/infrastructure/common/env.ts******
import { AxiosRequestConfig } from 'axios';
import dotenv from 'dotenv';
import { ServiceKey } from '../../domains/shipping/entities/constants';

switch (process.env.NODE_ENV) {
  case 'local':
    dotenv.config();
    break;
  case 'test':
    dotenv.config({ path: 'test/.env.test' });
    break;
  default:
    break;
}

export const parseEnv = <T = any>(envVar: string): T => {
  try {
    return JSON.parse(envVar);
  } catch {
    console.error(`Error at parsing ${envVar} environment variable`);
    return null;
  }
};

export const APP_ID = process.env.APP_ID || 'base-project';
export const REQUEST_LIMIT = process.env.REQUEST_LIMIT || '100kb';
export const ENVIRONMENT = process.env.NODE_ENV || 'development';
export const BASE_PATH = process.env.BASE_PATH || '/v1';
export const MONGO_URI = process.env.MONGO_URI;
export const LOG_LEVEL = process.env.LOG_LEVEL || 'info';
export const PORT = Number(process.env.PORT) || 3000;
export const SYSTEM = process.env.SYSTEM || 'matrix';
export const HTTP_REQUEST_TIMEOUT =
  Number(process.env.HTTP_REQUEST_TIMEOUT) || 20000;
export const ENABLE_HTTP_CLIENT_LOG =
  process.env.ENABLE_HTTP_CLIENT_LOG === 'true';
export const CONFIG_KEY = process.env.CONFIG_KEY || ServiceKey.CHECKOUT;
export const LOG_PROCESS_TIME =
  process.env.LOG_PROCESS_TIME === 'true' || false;
export const COUNTRY = process.env.COUNTRY || 'CL';

export const REDIS_HOST = process.env.REDIS_HOST;
export const REDIS_PORT = Number(process.env.REDIS_PORT);
export const REDIS_CONFIG = process.env.REDIS_CONFIG
  ? JSON.parse(process.env.REDIS_CONFIG)
  : {};
export const REDIS_EXP = Number(process.env.REDIS_EXP) || 1800;
export const ENABLE_BODY_LOGS = process.env.ENABLE_BODY_LOGS === 'true';
export const MONGO_DEBUG = process.env.MONGO_DEBUG === 'true';


// ****** Source: src/infrastructure/common/exceptions/BaseError.ts******
export default class BaseError extends Error {
  public status;
  public baseMessage;
  public details;
  public code;
  public name;
  constructor(message, { name, baseMessage, status, code, details }) {
    super(message);
    this.code = code;
    this.name = name;
    this.baseMessage = baseMessage;
    this.status = status;
    this.details = details;
  }
}


// ****** Source: src/infrastructure/common/exceptions/ClientException.ts******
import { AxiosError } from 'axios';
import { getStatusCode } from '../../gateways/apiClient';
import BaseError from './BaseError';

const code = 'CLIENT_COMMUNICATION_ERROR';

const getDetails = ({
  config: { url, method, params },
  response,
  message,
}: AxiosError) => ({
  url,
  method: method.toUpperCase(),
  data: response?.data,
  error: message,
  params,
});

export default class ClientException extends BaseError {
  constructor(clientError: AxiosError, name, baseMessage) {
    super(clientError.message, {
      name,
      baseMessage,
      status: getStatusCode(clientError),
      code,
      details: getDetails(clientError),
    });
    Object.setPrototypeOf(this, ClientException.prototype);
  }
}


// ****** Source: src/infrastructure/common/exceptions/EntityNotFoundException.ts******
import BaseError from './BaseError';
const code = 'ENTITY_NOT_FOUND_ERROR';
const name = 'EntityNotFoundException';
const baseMessage = 'Entity not found';
const status = 404;

export default class EntityNotFoundException extends BaseError {
  constructor(message, entity, entityName) {
    const details = {
      [`${entityName}`]: entity,
    };
    super(message, {
      code,
      name,
      baseMessage: message ?? baseMessage,
      status,
      details,
    });
    Object.setPrototypeOf(this, EntityNotFoundException.prototype);
  }
}


// ****** Source: src/infrastructure/common/exceptions/EntityValidationException.ts******
import { ZodIssue } from 'zod';
import BaseError from './BaseError';
const code = 'ENTITY_VALIDATION_ERROR';
const name = 'EntityValidationException';
const baseMessage = 'Entity Validation Failed';
const status = 400;

const formatIssues = (issues: ZodIssue[]) => {
  if (issues) {
    return issues.map((i) => `${i.path.join('/')}: ${i.message}`);
  }
  return null;
};

export default class EntityValidationException extends BaseError {
  constructor(message, entity) {
    const details = {
      validationErrors: formatIssues(message?.issues),
      entity,
    };
    super(message, {
      code,
      name,
      baseMessage,
      status,
      details,
    });
    Object.setPrototypeOf(this, EntityValidationException.prototype);
  }
}


// ****** Source: src/infrastructure/common/exceptions/ExtendedError.ts******
class ExtendedError extends Error {
  data: any;

  constructor(message, data) {
    super(message);
    this.data = data;
    this.name = 'ExtendedError';
  }
}

export { ExtendedError };


// ****** Source: src/infrastructure/common/handlers/logHandler.ts******
import { APP_ID, LOG_LEVEL, SYSTEM } from '../env';
import logger from '../logger';
import { getCountry, getTrackId } from './traceHandler';

export default class LogHandler {
  static logFormat = {
    system: SYSTEM,
    service: APP_ID,
  };

  static debug(message: any) {
    if (LOG_LEVEL !== 'debug') return;
    const infoToLog = LogHandler.buildInfoToLog(message, 'DEBUG');
    logger.debug(infoToLog);
  }

  static info(message: any) {
    const infoToLog = LogHandler.buildInfoToLog(message, 'INFO');
    logger.info(infoToLog);
  }

  static warn(message: any) {
    const infoToLog = LogHandler.buildInfoToLog(message, 'WARN');
    logger.info(infoToLog);
  }

  static error(message: any) {
    const infoToLog = LogHandler.buildInfoToLog(message, 'ERROR');
    logger.error(infoToLog);
  }

  private static buildInfoToLog = (message: any, severity: string) => ({
    trackId: getTrackId(),
    ...LogHandler.logFormat,
    message,
    severity,
  });
}


// ****** Source: src/infrastructure/common/handlers/traceHandler.ts******
import cls, { Namespace } from 'cls-hooked';

const name = 'requestSession';

export const createTrace = (): Namespace => {
  const instance: Namespace = cls.createNamespace(name);
  return instance as Namespace;
};

export const getCountry = (): string => cls.getNamespace(name)?.get('country');
export const setCountry = (country: string) =>
  cls.getNamespace(name).set('country', country);

export const getTrackId = (): string => cls.getNamespace(name)?.get('trackId');
export const setTrackId = (trackId: string) =>
  cls.getNamespace(name).set('trackId', trackId);


// ****** Source: src/infrastructure/common/logger.ts******
import pino from 'pino';
import { APP_ID, ENVIRONMENT, LOG_LEVEL } from './env';

const logger = pino({
  name: APP_ID,
  level: LOG_LEVEL,
  enabled: ENVIRONMENT != 'test',
  timestamp: () => `,"time":"${new Date(Date.now()).toISOString()}"`,
  base: null,
});

export default logger;


// ****** Source: src/infrastructure/common/responseManager.ts******
import { Response } from 'express';

const responseManager = <T = any>(
  res: Response,
  entity: T,
  statusCode?: number,
) => {
  if (entity)
    return res
      .status(statusCode || 200)
      .json(entity)
      .end();
  return res.status(404).end();
};

export const simulatorResponseManager = (res: Response, matrix) => {
  if (matrix?.message) return res.status(200).json(matrix.message).end();
  if (matrix?.error) return res.status(200).json(matrix.error).end();
  return res.status(200).json(matrix).end();
};

export default responseManager;


// ****** Source: src/infrastructure/common/timer.ts******
import { performance } from 'perf_hooks';

export default class Timer {
  private startTime: number;

  start = () => {
    this.startTime = performance.now();
    return this;
  };

  end = () => Number((performance.now() - this.startTime).toFixed(0));
}


// ****** Source: src/infrastructure/common/types.ts******
import { AxiosRequestConfig } from 'axios';

export interface HttpConfig {
  CL?: AxiosRequestConfig;
  PE?: AxiosRequestConfig;
}

export type CountryCode = 'CL' | 'PE';

export enum CurrencyCode {
  CL = 'CLP',
  PE = 'PEN',
}


// ****** Source: src/infrastructure/gateways/apiClient.ts******
import Axios, {
  AxiosResponse,
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
import logHandler from '../common/handlers/logHandler';
import ClientException from '../common/exceptions/ClientException';
import Timer from '../common/timer';
import { ENABLE_HTTP_CLIENT_LOG, HTTP_REQUEST_TIMEOUT } from '../common/env';

const getFullUrl = (request) => `${request.baseURL}${request.url}`;

const createStartRequestMessage = (request) => ({
  action: 'START_API_CALL',
  description: `[${request.method.toUpperCase()}] ${getFullUrl(
    request,
  )} - started`,
  details: {
    params: request.params,
    body: request.data,
    headers: request.headers,
  },
});

export const getStatusCode = (error: AxiosError) => {
  if (error?.code === 'ECONNABORTED') return 408;
  return error?.response?.status ?? 500;
};

declare module 'axios' {
  // eslint-disable-next-line @typescript-eslint/no-empty-interface
  export interface AxiosResponse<T = any> extends Promise<T> {}
}

export default class ApiClient {
  protected readonly client: AxiosInstance;

  private config: AxiosRequestConfig;

  private name: string;

  private timer: Timer;

  private readonly cacheClient: AxiosInstance;

  constructor(apiConfig: AxiosRequestConfig, name: string) {
    this.config = apiConfig;
    this.client = Axios.create({
      timeout: HTTP_REQUEST_TIMEOUT,
      ...this.config,
    });

    this.name = name;
    if (process.env.CACHE_API_CONFIG) {
      const CACHE_API_CONFIG = JSON.parse(process.env.CACHE_API_CONFIG);
      this.cacheClient = Axios.create({
        timeout: HTTP_REQUEST_TIMEOUT,
        ...CACHE_API_CONFIG,
      });
    }
    this.initResponseInterceptor();
  }

  private initResponseInterceptor = () => {
    this.client.defaults.headers.common['Content-Type'] = 'application/json';
    this.client.interceptors.request.use(
      this.requestHandler,
      this.errorHandler,
    );
    this.client.interceptors.response.use(
      this.responseHandler,
      this.errorHandler,
    );
    if (this.cacheClient) {
      this.cacheClient.defaults.headers.common['Content-Type'] =
        'application/json';
      this.cacheClient.interceptors.request.use(
        this.requestHandler,
        this.errorHandler,
      );
      this.cacheClient.interceptors.response.use(
        this.responseHandler,
        this.errorHandler,
      );
    }
  };

  private requestHandler = (request) => {
    this.timer = new Timer().start();
    if (ENABLE_HTTP_CLIENT_LOG)
      logHandler.info(createStartRequestMessage(request));
    return request;
  };

  private responseHandler = ({
    data,
    status,
    headers,
    config,
  }: AxiosResponse) => {
    if (ENABLE_HTTP_CLIENT_LOG)
      logHandler.info(this.createFinishRequestMessage(status, headers, config));
    return data;
  };

  private errorHandler = (error: AxiosError) => {
    if (ENABLE_HTTP_CLIENT_LOG)
      logHandler.error(this.createErrorRequestMessage(error));
    throw new ClientException(error, this.name, `${this.name}Exception`);
  };

  protected cacheableRequest = async <T = any>(
    key: string,
    callback: any,
    ttl?: number,
  ): Promise<T> => {
    if (this.cacheClient) {
      try {
        const result = await this.cacheClient.get(`/cache/${key}`);
        return result;
      } catch (error) {
        if (error?.status === 404) {
          const payload = await callback();
          await this.cacheClient.post('/cache', {
            key,
            payload,
            ttl,
          });
          return payload;
        }
        return callback();
      }
    }
    return callback();
  };

  private createErrorRequestMessage = (error) => {
    const statusCode = getStatusCode(error.response);
    return {
      action: 'API_CALL_ERROR',
      description: `[${error.config.method.toUpperCase()}] ${getFullUrl(
        error.config,
      )} - finished with error, with status code ${statusCode}`,
      details: {
        status: statusCode,
        body: error.response ? error.response.data : null,
        headers: error.response ? error.response.headers : null,
        timelapseMs: this.timer.end(),
      },
    };
  };

  private createFinishRequestMessage = (status, headers, config) => ({
    action: 'END_API_CALL',
    description: `[${config.method.toUpperCase()}] ${getFullUrl(
      config,
    )} - finished successfully with status code ${status}`,
    details: {
      status,
      headers,
      timelapseMs: this.timer.end(),
    },
  });
}


// ****** Source: src/infrastructure/gateways/cacheClient.ts******
import IORedis, { Redis, RedisOptions } from 'ioredis';
import LogHandler from '../common/handlers/logHandler';
import { COUNTRY, REDIS_CONFIG, REDIS_EXP } from '../common/env';

const clients: [string, CacheClient][] = [];

class CacheClient {
  private redisInstance: Redis;
  private healthCheck: boolean;
  private prefix: string;
  private errorLogged: boolean;

  constructor(options: RedisOptions) {
    this.prefix = options.keyPrefix;
    this.redisInstance = new IORedis(options);
    this.healthCheck = false;
    this.errorLogged = false;

    this.redisInstance.on('ready', async () => {
      LogHandler.info({
        action: 'REDIS_CONNECTION_SUCCESSFUL',
        details: `Redis connected to: ${this.redisInstance.options.host}:${this.redisInstance.options.port}`,
      });
      this.healthCheck = true;
    });
    this.redisInstance.on('error', (err) => {
      if (this.errorLogged) return;
      LogHandler.error({
        action: 'REDIS_CONNECTION_ERROR',
        details: `Redis error: ${err.message}`,
      });
      this.healthCheck = false;
      this.errorLogged = true;
    });
  }

  static createKey(key: string | Record<string, any>): string {
    switch (typeof key) {
      case 'string':
      case 'number':
        return String(key);
      default:
        return Object.values(key).join('');
    }
  }

  async get<T = any>(key: string, returnTTL = false): Promise<T> {
    const resp = JSON.parse(
      await this.redisInstance.get(CacheClient.createKey(key)),
    ) as T;
    if (returnTTL) {
      const ttl = JSON.parse(
        String(await this.redisInstance.ttl(CacheClient.createKey(key))),
      );
      return { ...resp, ttl };
    }
    return resp;
  }

  async set(key: string, value: any, exp = null): Promise<boolean> {
    try {
      await this.redisInstance.set(
        CacheClient.createKey(key),
        JSON.stringify(value),
        'EX',
        exp || REDIS_EXP,
      );
    } catch (e) {
      LogHandler.error(e);
    }
    return true;
  }

  async remove(key: string): Promise<boolean> {
    try {
      await this.redisInstance.del(CacheClient.createKey(key));
    } catch (e) {
      LogHandler.error(e);
    }
    return true;
  }

  async wrapperQuery<T = any>(
    key: string,
    callbackFn: () => Promise<T>,
  ): Promise<T> {
    try {
      if (this.healthCheck) {
        let result = await this.get<T>(key);
        if (!result) {
          result = await callbackFn();
          await this.set(key, result);
        }
        return result;
      }
      return callbackFn();
    } catch (e) {
      LogHandler.error(e);
      return callbackFn();
    }
  }

  async deleteAll(): Promise<void> {
    const keys = await this.redisInstance.keys(`${this.prefix}*`);
    await Promise.all(
      keys.map((key) => this.redisInstance.del(key.split(':')[1])),
    );
  }

  async deleteByPattern(pattern: string) {
    const keys = await this.redisInstance.keys(`${this.prefix}${pattern}*`);
    LogHandler.info(`Deleting ${keys.length} keys by pattern ${pattern}`);
    await Promise.all(
      keys.map((key) => this.redisInstance.del(key.split(':')[1])),
    );
    LogHandler.info('Keys deleted');
  }

  async delete(key: string) {
    LogHandler.debug(`Deleting ${key} key`);
    await this.redisInstance.del(key);
    LogHandler.debug('Key deleted');
  }

  get HealthCheck() {
    return this.healthCheck;
  }
}

export const initCacheClient = (): void => {
  const { CL, PE } = REDIS_CONFIG || {};
  if (REDIS_CONFIG && CL && PE) {
    clients.push(['CL', new CacheClient(CL)]);
    clients.push(['PE', new CacheClient(PE)]);
  }

  if (REDIS_CONFIG && !CL && !PE) {
    clients.push(['CORP', new CacheClient(REDIS_CONFIG)]);
  }
};

export const getCacheClient = (): CacheClient => {
  const client = clients.find(([countryCode]) => countryCode === COUNTRY);
  if (client) return client[1];
  return clients.length > 0 ? clients[0][1] : null;
};


// ****** Source: src/infrastructure/helpers/date.ts******
import moment from 'moment';
import momentTimeZone from 'moment-timezone';
import { COUNTRY } from '../common/env';

const DATE_FORMAT = 'DD-MM-YYYY';

const DEFAULT_DAYS = [
  'sunday',
  'monday',
  'tuesday',
  'wednesday',
  'thursday',
  'friday',
  'saturday',
];

export const getNewDate = (date = null) => {
  // FIXME: Separar función del helper ya que hace dos cosas distintas, uno para devolver fecha nueva y otro para formatear fecha existente a moment
  const timeZone = {
    CL: {
      zone: 'cl-CL',
      timeZone: 'America/Santiago',
    },
    PE: {
      zone: 'pe-PE',
      timeZone: 'America/Lima',
    },
  };
  if (date) {
    return momentTimeZone(date).tz(timeZone[COUNTRY].timeZone).toDate();
  }
  const newDate = momentTimeZone.tz(timeZone[COUNTRY].timeZone);
  return moment(
    newDate.format('YYYY-MM-DD HH:mm'),
    'YYYY-MM-DD HH:mm',
  ).toDate();
};

export const getDateUtc = (date) => moment.utc(date).toDate();

export const makeDate = (date, cleanHours = true) => {
  const newDate = getNewDate(date);
  if (cleanHours) {
    return moment
      .utc(newDate)
      .hours(0)
      .minutes(0)
      .seconds(0)
      .milliseconds(0)
      .toDate();
  }
  return newDate;
};

export const addDays = (date, days = 0) => {
  if (days > 0) {
    return moment(getNewDate(date)).add(days, 'd').toDate();
  }
  return date;
};

export const evaluateDatesArray = async (
  datesArray,
  increment,
  holidays,
  validDayFn,
  frequency = [],
  isManufactureCalc = false,
) => {
  const newDatesArray = [];
  if (isManufactureCalc) {
    for (const currentDate of datesArray) {
      let internDate = currentDate;
      for (const _ of Array(increment).fill(0)) {
        const newDate = new Date(addDays(internDate, 1));
        internDate = await validDayFn(newDate, holidays, frequency);
      }
      newDatesArray.push(internDate);
    }
    return newDatesArray;
  }
  for (const currentDate of datesArray) {
    let newDate = new Date(addDays(currentDate, increment));
    newDate = await validDayFn(newDate, holidays, frequency);
    newDatesArray.push(newDate);
  }
  return newDatesArray;
};

export const getDDMMYYYYByDate = (date, separator = '/') => {
  if (date) {
    return moment.utc(date).format(`DD${separator}MM${separator}YYYY`);
  }
  return false;
};

export const isBetween = (dateCheck, dateFrom, dateTo) =>
  moment.utc(dateCheck).isBetween(dateFrom, dateTo);

export const dayBetween = (init, end, abs = true) => {
  // TODO: refactor function to fix types problems
  const oneDay = 24 * 60 * 60 * 1000;
  const firstDate: any = makeDate(init);
  const secondDate: any = makeDate(end);
  if (abs) return Math.round(Math.abs((firstDate - secondDate) / oneDay));
  return Math.round((firstDate - secondDate) / oneDay);
};

// TODO: Revisar existencia de dos metodos similares en nombre
export const isOutSideOfCutTime = (date, cutTime) => {
  const arrayWeek = parseArrayDayOfWeek(cutTime);
  const cutTimeOfSaleDay =
    arrayWeek[date.getDay()] &&
    Number(arrayWeek[date.getDay()].replace(':', ''));
  const hourSale = Number(getHourMin(date).replace(':', ''));
  return cutTimeOfSaleDay ? hourSale > cutTimeOfSaleDay : false;
};

// TODO: Revisar existencia de dos metodos similares en nombre

export const isOutOfCutTime = (date, cutTime) => {
  const [h, m] = cutTime.split(':').map(Number);
  const cutTimeAsDate = new Date(date).setHours(h, m);
  const timeNumber = Number(moment.utc(date).format('HHmm'));
  const cutTimeNumber = Number(moment.utc(cutTimeAsDate).format('HHmm'));
  return timeNumber > cutTimeNumber;
};

export const parseArrayDayOfWeek = (week, mode = 'number') => {
  let parse = {};
  const days = {
    Do: mode === 'number' ? 0 : 'sunday',
    Lu: mode === 'number' ? 1 : 'monday',
    Ma: mode === 'number' ? 2 : 'tuesday',
    Mi: mode === 'number' ? 3 : 'wednesday',
    Ju: mode === 'number' ? 4 : 'thursday',
    Vi: mode === 'number' ? 5 : 'friday',
    Sa: mode === 'number' ? 6 : 'saturday',
  };
  for (const day of week) {
    parse = { ...parse, [days[day.label]]: day.value };
  }
  return parse;
};

export const getHourMin = (date) => {
  const currentDate = date || getNewDate();
  return moment.utc(currentDate).format('HH:mm');
};

export const isSameOrAfter = (date, dateCheck, type = 'day' as any) =>
  moment.utc(date).isSameOrAfter(moment.utc(dateCheck), type);

export const getDayNameFromDate = (date) =>
  moment.utc(date).format('dddd').toLowerCase();

export const checkDateRange = (init, end, date) =>
  end.getTime() >= date.getTime() && date.getTime() >= init.getTime();

export const dateDiff = (date, dateCheck, type = 'day' as any) =>
  moment.utc(date).diff(dateCheck, type);

export function checkRoute(date, availableDays) {
  const dayFormated = DEFAULT_DAYS[date.getDay()];
  return availableDays[dayFormated];
}

export const setFormatDateFromTo = (
  date,
  from = DATE_FORMAT,
  to = 'MM-DD-YYYY',
) => moment.utc(date, from).format(to);

export function checkExceptDays(compareDate, notAvailableDates = []) {
  const formatedDate = setFormatDateFromTo(compareDate);
  for (const date of notAvailableDates) {
    const { day, month, year } = date;
    const excetpDate = new Date(year, month - 1, day);
    const formatedExcept = setFormatDateFromTo(excetpDate);
    return formatedDate === formatedExcept;
  }
  return false;
}

export const lessDays = (date, days = 0) => {
  if (days > 0) {
    return moment.utc(date).subtract(days, 'd').toDate();
  }
  return date;
};

export const isSame = (
  date,
  dateCheck,
  format = DATE_FORMAT,
  type = 'day' as any,
) => {
  if (format) {
    return moment.utc(date, format).isSame(moment.utc(dateCheck), type);
  }
  return moment.utc(date).isSame(moment.utc(dateCheck), type);
};

export const isAfter = (date, dateCheck, type = 'day' as any) =>
  moment.utc(date).isAfter(dateCheck, type);

export const getFormatDate = (date, format = DATE_FORMAT) =>
  moment.utc(date).format(format);

export const getArrayOfDatesBetween = (
  dateStart,
  dateEnd,
  outputFormat = null,
  closed = true,
) => {
  let range = [];
  let daysToAdd = 0;
  if (new Date(dateStart) <= new Date(dateEnd)) {
    daysToAdd = dayBetween(dateStart, dateEnd, true);
    range = getArrayOfDates(dateStart, daysToAdd, outputFormat);
  }
  if (closed) {
    range.unshift(moment.utc(dateStart).format(outputFormat));
  }
  return range;
};

const getArrayOfDates = (
  dateStart,
  daysToAdd = 0,
  outputFormat = DATE_FORMAT,
) => {
  const dates = [];
  for (let i = 0; i < daysToAdd; i++) {
    dates.push(
      moment
        .utc(dateStart)
        .add(i + 1, 'd')
        .format(outputFormat),
    );
  }
  return dates;
};


// ****** Source: src/infrastructure/helpers/index.ts******
import { BigNumber, all, create } from 'mathjs';

const math = create(all, { number: 'BigNumber' });

export const addDecimals = (x = 0, y = 0) => {
  const xMath = math.bignumber(x);
  const yMath = math.bignumber(y);
  return math.add(xMath, yMath).toNumber();
};

export const multiplyDecimals = (x = 0, y = 0) => {
  const xMath = math.bignumber(x);
  const yMath = math.bignumber(y);
  const multiplication = math.multiply(xMath, yMath) as BigNumber;
  return multiplication.toNumber();
};

export class Timer {
  private processStart: number;
  private processName: string;

  constructor() {
    this.processStart = 0;
    this.processName = '';
  }

  start(processName: string) {
    this.processStart = performance.now();
    this.processName = processName;
    return this;
  }

  stop() {
    const executionTime = performance.now() - this.processStart;
    const logInfo = `${this.processName} processed in ${executionTime} ms`;
    return this.processName ? logInfo : executionTime;
  }
}


// ****** Source: src/infrastructure/helpers/mongoHelper.ts******
import { Types } from 'mongoose';

export const getCountryId = {
  CL: '5d2f3e139c66136f62dafb47',
  PE: '5d2f3e289c66136f62dafb48',
};

export const getObjectIdFromMongoose = (id = null) => new Types.ObjectId(id);


// ****** Source: src/infrastructure/helpers/schedule.ts******
export const isValidCapacity = (capacityData) => {
  const { active, assigned, occupied } = capacityData;
  return active && assigned > 0 && occupied < assigned;
};

export const filterTypesOfServicesWithPicking = (
  data,
  isWithCalculationForMixedOrder = false,
) => {
  const { products } = data;
  return {
    ...data,
    products: products.map((p, i) => {
      p.typeofServices = p.typeofServices.filter(
        (tos) =>
          (tos.existsPickingSchedule && tos.existPickingAvailable) ||
          (!isWithCalculationForMixedOrder && i > 0),
      );
      return p;
    }),
  };
};

export const formatMatrixError = (data, requestToMatrix) => {
  const {
    products: [product],
  } = data;
  return {
    matrix: {
      error: { msg: requestToMatrix.message, data: { sku: product.sku } },
    },
  };
};


// ****** Source: src/infrastructure/helpers/validationHelper.ts******
import { SafeParseError, z } from 'zod';
import EntityValidationException from '../common/exceptions/EntityValidationException';

export const validateSchema =
  (schema: z.AnyZodObject, entityName: string) =>
  <T>(data: T) => {
    const result = schema.passthrough().safeParse({
      ...data,
    });

    if (!result.success) {
      throw new EntityValidationException(
        (result as SafeParseError<T>).error,
        entityName,
      );
    }

    return result.data;
  };


// ****** Source: src/infrastructure/middlewares/error.ts******
import { Response, NextFunction } from 'express';
import logHandler from '../common/handlers/logHandler';

export default function errorMiddleware(
  err,
  req: any,
  res: Response,
  next: NextFunction,
) {
  const statusCode = err?.status || 500;
  const errorResponse = {
    message: err?.baseMessage || err?.message || 'Unexpected error',
    statusCode,
    error: err?.code || 'Bad Request',
  };
  logHandler.error({
    action: 'FINISH_REQUEST_WITH_ERROR',
    description: `[${req.method}] ${req.originalUrl}`,
    status: statusCode,
    details: {
      ...errorResponse,
      stack: err?.stack,
    },
  });
  res.status(statusCode).json(err?.isBoom ? err.output.payload : errorResponse);
  next();
}


// ****** Source: src/infrastructure/middlewares/request.ts******
import { Request, Response, NextFunction } from 'express';
import { v4 } from 'uuid';
import { BASE_PATH, ENABLE_BODY_LOGS } from '../common/env';
import logHandler from '../common/handlers/logHandler';
import { setTrackId } from '../common/handlers/traceHandler';
import Timer from '../common/timer';

const preRequestAction = (request) => {
  const { headers, originalUrl, body, params, method } = request;
  const trackId = headers['x-track-id'] || v4();
  request.trackId = trackId;
  setTrackId(trackId);

  const bodyToLog = ENABLE_BODY_LOGS ? body : {};

  logHandler.info({
    action: 'START_REQUEST',
    description: `[${method}] ${originalUrl}`,
    details: {
      body: JSON.stringify(bodyToLog),
      params,
    },
  });
};

const postRequestAction = (request, response, timer: Timer) => {
  const { originalUrl, method } = request;
  const { statusCode } = response;
  logHandler.info({
    action: 'END_REQUEST',
    description: `[${method}] ${originalUrl}`,
    status: statusCode,
    timelapseMs: timer.end(),
  });
};

export default function beforeRequestMiddleware(
  request: Request & { trackId: string },
  response: Response,
  next: NextFunction,
) {
  const { path } = request;
  if (path.startsWith(BASE_PATH)) {
    const timer = new Timer().start();
    preRequestAction(request);
    response.set('x-track-id', request.trackId);
    response.on('finish', () => {
      postRequestAction(request as any, response, timer);
    });
  }
  next();
}


// ****** Source: src/infrastructure/middlewares/trace.ts******
import { Request, Response, NextFunction } from 'express';
import { Namespace } from 'cls-hooked';
import { createTrace } from '../common/handlers/traceHandler';

const nameSpace: Namespace = createTrace();

export default function traceMiddleware(
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  nameSpace.bindEmitter(req);
  nameSpace.bindEmitter(res);
  nameSpace.run(() => {
    next();
  });
}


// ****** Source: src/infrastructure/repositories/mongoConnector.ts******
import { MongooseOptions, connect as connectDB, set } from 'mongoose';
import { MONGO_DEBUG, MONGO_URI } from '../common/env';
import logger from '../common/logger';

const connect = async () => {
  try {
    const options: MongooseOptions = {
      autoIndex: true,
    };
    set('debug', MONGO_DEBUG);
    const { connection } = await connectDB(MONGO_URI, options);
    logger.info(`MongoDB connected: ${connection.host}/${connection.name}`);
  } catch (err) {
    logger.fatal(err.message);
    process.exit(1);
  }
};

export default connect;


// ****** Source: src/infrastructure/routes/index.ts******
import { Router } from 'express';
import openApiRoute from './openApi';
import { registerAllRoutes } from './utils';
import ShippingController from '../../domains/shipping/controllers';
import ScheduleController from '../../domains/schedule/controllers';
import FulfillmentController from '../../domains/fulfillment/controllers';

const router = Router();
registerAllRoutes(router, [
  ShippingController,
  ScheduleController,
  FulfillmentController,
]);
router.use(openApiRoute);

export default router;


// ****** Source: src/infrastructure/routes/openApi.ts******
import { Router } from 'express';
import path from 'path';
import swaggerUi from 'swagger-ui-express';
import YAML from 'yamljs';

const router = Router();
const root = path.normalize(__dirname + '/..');
const swaggerDocument = YAML.load(`${root}/openApi/spec.yaml`);
router.use('/api-explorer', swaggerUi.serve);
router.get('/api-explorer', swaggerUi.setup(swaggerDocument));

export default router;


// ****** Source: src/infrastructure/routes/utils.ts******
import { Router } from 'express';
import { ClassType, RouteDefinition } from '../../types/decorators';
import LogHandler from '../common/handlers/logHandler';
import { BASE_PATH, ENVIRONMENT } from '../common/env';

export const registerAllRoutes = (router: Router, controllers: ClassType[]) => {
  controllers.forEach((controller) => {
    const instance = new controller();
    const prefix = Reflect.getMetadata('prefix', controller);
    const routes = Reflect.getMetadata(
      'routes',
      controller,
    ) as RouteDefinition[];

    routes.forEach((route) => {
      router[route.method](
        BASE_PATH + prefix + route.path,
        instance[route.methodName],
      );
    });
  });

  if (ENVIRONMENT === 'local')
    LogHandler.info({
      action: 'REGISTER_ROUTES',
      routes: router.stack.map(
        (x) =>
          `${JSON.stringify(Object.keys(x.route.methods))
            .toUpperCase()
            .replaceAll('"', '')} ${x.route.path}`,
      ),
    });
};


// ****** Source: src/infrastructure/server.ts******
import 'reflect-metadata';
import express, { RequestHandler } from 'express';
import actuator from 'express-actuator';
import compression from 'compression';
import path from 'path';
import http from 'http';
import cors from 'cors';
import logger from './common/logger';
import { APP_ID, ENVIRONMENT, REQUEST_LIMIT } from './common/env';
import requestMiddleware from './middlewares/request';
import routes from './routes';
import errorMiddleware from './middlewares/error';
import traceMiddleware from './middlewares/trace';

const app = express();
app.disable('x-powered-by');
const root = path.normalize(__dirname + '/../..');

export default class ExpressServer {
  constructor() {
    app.set('appPath', root + 'client');
    app.use(express.json({ limit: REQUEST_LIMIT }) as RequestHandler);
    app.use(compression());
    app.use(
      express.urlencoded({
        extended: true,
        limit: REQUEST_LIMIT,
      }) as RequestHandler,
    );
    app.use(express.text({ limit: REQUEST_LIMIT }) as RequestHandler);
    app.use(actuator());
    app.use(cors());
    app.use(express.static(`${root}/public`));
    app.enable('case sensitive routing');
    app.enable('strict routing');
    app.use(traceMiddleware);
    app.use(requestMiddleware);
    app.use(routes);
    app.use(errorMiddleware);
  }

  listen(port: number): http.Server {
    const welcome = (p: number) => () =>
      logger.info(`${APP_ID} running in ${ENVIRONMENT} on port: ${p}`);
    return http.createServer(app).listen(port, welcome(port));
  }
}


// ****** Source: src/types/decorators.ts******
export type RestMethod = 'get' | 'post' | 'delete' | 'put' | 'patch';

export type ClassType<C extends object = object> = new (...args: any) => C;

export interface RouteDefinition {
  path: string;
  method: RestMethod;
  methodName: string;
}

const routeDecoratorBase =
  (method: RestMethod, path: string) => (target: any, propertyKey: string) => {
    if (!Reflect.hasMetadata('routes', target.constructor)) {
      Reflect.defineMetadata('routes', [], target.constructor);
    }
    const routes = Reflect.getMetadata(
      'routes',
      target.constructor,
    ) as RouteDefinition[];
    routes.push({
      method,
      path,
      methodName: propertyKey,
    });
    Reflect.defineMetadata('routes', routes, target.constructor);
  };

export const Controller =
  (prefix: string = ''): ClassDecorator =>
  (target: any) => {
    Reflect.defineMetadata('prefix', prefix, target);
    if (!Reflect.hasMetadata('routes', target)) {
      Reflect.defineMetadata('routes', [], target);
    }
  };

export const Get = (path: string = '') => routeDecoratorBase('get', path);
export const Post = (path: string = '') => routeDecoratorBase('post', path);
export const Put = (path: string = '') => routeDecoratorBase('put', path);
export const Patch = (path: string = '') => routeDecoratorBase('patch', path);
export const Delete = (path: string = '') => routeDecoratorBase('delete', path);


// ****** Source: src/types/enums.ts******
export enum HIERARCHY_TYPE {
  DEPARTMENT,
  LINE,
  SUBLINE,
  SKU,
}

export enum CHANNEL_SALE {
  POS,
  TVI,
}

export enum LAST_MILE_FORMAT {
  HOUR,
  DAY,
}


// ****** Source: src/types/request/CreateRequestPayload.ts******
import { InsertManyOptions } from 'mongoose';
import { z } from 'zod';
import { validateSchema } from '../../infrastructure/helpers/validationHelper';

export interface CreateRequestPayload<T = any> {
  documents: T[];
  options?: InsertManyOptions;
}

const createRequestPayloadSchema = z.object({
  documents: z.object({}).array(),
  options: z.object({}).optional(),
});

export const validateCreateRequestPayload = validateSchema(
  createRequestPayloadSchema,
  'CreateRequestPayload',
);


// ****** Source: src/types/request/DeleteRequestPayload.ts******
import { FilterQuery, QueryOptions } from 'mongoose';
import { z } from 'zod';
import { validateSchema } from '../../infrastructure/helpers/validationHelper';

export interface DeleteRequestPayload<T = any> {
  query: FilterQuery<T>;
  options?: QueryOptions;
}

const deleteRequestPayloadSchema = z.object({
  query: z.object({}),
  options: z.object({}).optional(),
});

export const validateDeleteRequestPayload = validateSchema(
  deleteRequestPayloadSchema,
  'DeleteRequestPayload',
);


// ****** Source: src/types/request/FindRequestPayload.ts******
import { z } from 'zod';
import { FilterQuery, ProjectionType, QueryOptions } from 'mongoose';
import { validateSchema } from '../../infrastructure/helpers/validationHelper';

export interface FindRequestPayload<T = any> {
  query: FilterQuery<T>;
  projection?: ProjectionType<T>;
  options?: QueryOptions;
}

const findRequestPayloadSchema = z.object({
  query: z.object({}),
  projection: z.object({}).optional(),
  options: z.object({}).optional(),
});

export const validateFindRequestPayload = validateSchema(
  findRequestPayloadSchema,
  'FindRequestPayload',
);


// ****** Source: src/types/request/MutationRequestPayload.ts******
import {
  MongooseBulkWriteOptions,
  MongooseBulkWritePerWriteOptions,
  mongo,
} from 'mongoose';
import { z } from 'zod';
import { validateSchema } from '../../infrastructure/helpers/validationHelper';

const mutationRequestPayloadSchema = z.object({
  writes: z.object({}).array(),
  options: z.object({}).optional(),
});

export const validateMutationRequestPayload = validateSchema(
  mutationRequestPayloadSchema,
  'MutationRequestPayload',
);

export interface MutationRequestPayload {
  writes: (mongo.AnyBulkWriteOperation & MongooseBulkWritePerWriteOptions)[];
  options?: MongooseBulkWriteOptions;
}


// ****** Source: src/types/request/UpdateRequestPayload.ts******
import { FilterQuery, QueryOptions, UpdateQuery } from 'mongoose';
import { z } from 'zod';
import { validateSchema } from '../../infrastructure/helpers/validationHelper';

export interface UpdateRequestPayload<T = any> {
  query: FilterQuery<T>;
  update: UpdateQuery<T>;
  options?: QueryOptions;
}

const updateRequestPayloadSchema = z.object({
  query: z.object({}),
  update: z.object({}),
  options: z.object({}).optional(),
});

export const validateUpdateRequestPayload = validateSchema(
  updateRequestPayloadSchema,
  'UpdateRequestPayload',
);


// ****** Source: tsconfig.build.json******
{
  "compilerOptions": {
    "module": "commonjs",
    "sourceMap": true,
    "outDir": "dist",
    "rootDir": "./",
    "moduleResolution": "node",
    "typeRoots": ["node_modules/@types"],
    "lib": ["ESNext"],
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "exclude": [
    "node_modules",
    "test/setup.ts",
    "build.ts",
    "**/*.test.ts",
    "test/**/*.js",
    "test/**/*.ts",
    "test/**/*.test.ts"
  ]
}


// ****** Source: tsconfig.json******
{
  "compilerOptions": {
    "module": "commonjs",
    "sourceMap": true,
    "outDir": "dist",
    "rootDir": "./",
    "moduleResolution": "node",
    "typeRoots": ["node_modules/@types"],
    "lib": ["ESNext"],
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", "test/setup.ts"]
}


